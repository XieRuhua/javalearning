# 分库分表概念及解决方案

[文档内容参考1：分库分表的5大方案，百度、腾讯、阿里等大厂都在用！](https://blog.51cto.com/14442094/2450074)  
[文档内容参考2：MyBatis实现Mysql数据库分库分表操作和总结！](https://www.jb51.net/article/121743.htm)  
[文档内容参考3：分库分表平滑扩容](https://www.cnblogs.com/barrywxx/p/11532122.html)

[toc]
## 一、基本概念

### 1. 出现原因（为什么要分库分表？）
在当前海量数据的互联网环境下，初试的 **单表单库** 已经无法 **`高效`** 的应付日常业务了。  

而目前较为主流的关系型数据库都是有性能瓶颈的。如目前应用最为广泛的`MySQL`， 当 `MySQL` 单表数据量达到千万级别或者存储量量超过`100G`以上时，无论如何对 `MySQL` 进行优化、查询如何简单，`MySQL` 的性能都会显著降低。

作为一个数据库，作为数据库中的一张表，随着用户的增多、随着时间的推移，总有一天，数据量会大到一个难以处理的地步。这时仅仅一张表的数据就已经超过了`千万`，无论是 **查询** 还是 **修改** ，对于它的操作都会很耗时，这时就需要进行数据库 **切分** 的操作了。

### 2. 解决方法
**常见的性能瓶颈大致分为两个：**  
- **`IO`瓶颈：**  
	- 1.`磁盘读IO瓶颈`：热点数据太多，数据库缓存放不下，每次查询时会产生大量的`物理I/O`操作，降低查询速度 --> **<font color="red">分库和垂直分表</font>** 。  
	- 2.`网络IO瓶颈`：请求的数据太多，网络带宽不够 --> **<font color="red">分库</font>** 。
- **`CPU`瓶颈：**  
	- 1.SQL问题：如SQL中包含`join`，`group by`，`order by`（关联操作），非索引字段条件查询等，增加`CPU`运算的操作 --> **<font color="red">`SQL`优化，建立合适的索引，在业务逻辑（`Service`）层进行业务计算等</font>** 。  
	- 2.单表数据量太大：查询时扫描的行太多，`SQL`效率低，`CPU`率先出现瓶颈 --> **<font color="red">水平分表</font>** 。

## 二、水平拆分
### 1. 概念
把一张表的数据按照一定规则分离成几张一模一样的表，只是表的名字不同。  
这种切分适合于一张表的数据量过大而导致操作时间变慢的情况，如保存的一些记录表等。

### 2. 拆分策略
1. **“`%`” 取模：** 通过对需要分表的`主键ID`（通常为自增）进行取模运算，然后操作对应的表。  
2. **`Hash`（哈希）：** 这中模式允许通过对表的一个或多个列的`Hash Key`进行计算，最后通过这个`Hash码`不同数值对应的数据区域进行分区；  
例如可以建立一个对表主键进行分区的表。  
3. **`Key`（键值）：** 上面`Hash模式`的一种延伸，这里的`Hash Key`是`MySQL`系统产生的。  
4. **`Range`（范围）：** 根据不同的日期或某个确定的值分表，枚举范围（如用户自增ID `1-10000` 操作第一张表，用户自增ID `10001-20000`操作第二张表.....）。  
5. **`composite`（复合模式）：**  以上模式的组合使用。　

### 3. 水平分库
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/JavaLearning/数据库/分库分表概念/水平分库.png)
</center>

**概念：**  
以字段为依据，按照一定策略，将一个库中的数据拆分到多个库中。

**结果：**  
* 每个库的结构都一样；
* 每个库的数据都不一样，没有交集；
* 所有库的并集是全量数据。  

**场景：**  
系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。 

**分析：**  
库多了，`IO`和`CPU`的压力自然可以成倍缓解。

### 3. 水平分表
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/JavaLearning/数据库/分库分表概念/水平分表.png)
</center>

**概念：**  
以字段为依据，按照一定策略，将一个库中的数据拆分到多个库中。

**结果：**  
* 每个表的结构都一样；
* 每个表的数据都不一样，没有交集；
* 所有表的并集是全量数据。  

**场景：**  
系统绝对并发量并没有上来，只是单表的数据量太多，影响了`SQL`效率，加重了`CPU`负担，以至于成为瓶颈。 

**分析：**  
水平分表之后，单表的数据量少了，单次`SQL`执行效率高，自然减轻了`CPU`的负担。

## 三、垂直拆分
把不同的业务模块分成不同的数据库，这些业务模块直接最好是`0耦合`（简单的说就是毫无关系）。  
这主要是适合数据量普遍较大，而且业务场景比较分散，互相之间没有逻辑关系的情况。

### 1. 垂直分库
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/JavaLearning/数据库/分库分表概念/垂直分库.png)
</center>

**概念：**  
以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。

**结果：**  
* 每个库的结构都不一样；
* 每个库的数据都不一样，没有交集；
* 所有库的并集是全量数据。  

**场景：**  
系统绝对并发量上来了，并且可以抽象出单独的业务模块。  

到这一步，基本上就可以服务化了。
例如，随着业务的发展一些公用的配置表、字典表等越来越多，这时可以将这些表拆到单独的库中，甚至可以服务化。

### 2. 垂直分表
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/JavaLearning/数据库/分库分表概念/垂直分表.png)
</center>

**概念：**  
以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。

**结果：**  
* 每个表的结构都不一样；
* 每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据；
* 所有表的并集是全量数据。  

**场景：**  
系统绝对并发量并没有上来，表的记录并不多，但是字段多（可能满足`3FN`无法再拆分），并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的`随机读IO`，产生`IO瓶颈`。

**可以用列表页和详情页的方式来帮助理解。**  
垂直分表的拆分原则是将热点数据（可能会冗余经常一起查询的数据）放在一起作为主表，非热点数据放在一起作为扩展表。这样更多的热点数据就能被缓存下来，进而减少了`随机读IO`。拆了之后，要想获得全部数据就需要关联两个表来取数据。  
但记住，千万别用`join`，因为`join`不仅会增加`CPU`负担并且会将两个表耦合在一起（前提是必须在一个数据库实例上）。关联数据，应该在业务代码`Service`层做处理，分别获取主表和扩展表数据然后用关联字段关联得到全部数据。

## 四、分库分表的扩容
### 场景（举例：取模的方式水平分库扩展）
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/JavaLearning/数据库/分库分表概念/取模的方式水平分库扩展1.png)
</center>

**如上我们可以看到，数据可以均衡的分配到`3`个数据库里面。**

但是，如果后续业务发展的速度很快，用户量数据大量上升，当前容量不足以支撑，应该怎么办？  
这时候需要对数据库进行 **水平扩容** ，再增加新库来分解。新库加入之后，原先`sharding`到`3`个库的数据，就可以`sharding`到`4`个库里面了。  

**如下：**  
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/JavaLearning/数据库/分库分表概念/取模的方式水平分库扩展2.png)
</center>

**不过此时由于分片规则进行了变化(`user_id%3` 变为`user_id%4`)，大部分的数据，无法命中在原有的数据库上了，需要重新分配，大量数据需要迁移。**  
比如之前`user_id=1`通过`user_id1%3` 分配在 **`A库`** 上，新加入 **`D库`** 之后，算法改为`user_id1%4` 了，此时有可能就分配在 **`B库`** 上面了。

如果你有看到之前《一致性哈希的原理与实践》，就会发现新增一个节点，大概会有`90%`的数据需要迁移，这个对`DB`同学的压力还是蛮大的，那么如何应对？

### 1. 停服迁移
停服迁移是最常见的一种方案了，一般如下流程:  
1. 预估停服时间，发布停服公告；
2. 停服，通过事先做好的数据迁移工具，按照新的分片规则，进行迁移；
3. 修改分片规则；
4. 启动服务。

这种方式比较安全，停服之后没有数据写入，能够保证迁移工作的正常进行，没有一致性的问题。唯一的问题，就是停服了和时间压力了。  
**停服**，伤害用户体验，同时也降低了服务器的可用性，必须在制定时间内完成迁移，如果失败，需要择日再次进行。同时增加了开发人员的压力，容易发生大的事故，且数据量的巨大的时候，迁移需要大量时间。

### 2. 升级从库
线上数据库，我们为了保持其高可用，一般都会每台`主库`配一台`从库`， **读写在主库，然后主从同步到从库** 。如下：`A、B`是主库，`A0、B0`是从库。
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/JavaLearning/数据库/分库分表概念/取模的方式水平分库扩容-升级从库.png)
</center>

**此时，当需要扩容的时候，我们把`A0`和`B0`升级为新的主库节点，如此由`2`个分库变为`4`个分库。同时在上层的分片配置，做好映射，规则如下:**
* `user_id%4=0` 和 `user_id%4=2` 的分别指向 **`A`** 和 **`A0`** ，也就是之前指向 `user_id%2=0` 的数据，分裂为 `user_id%4=0` 和 `user_id%4=2`  
* `user_id%4=1` 和 `user_id%4=3` 的指向 **`B`** 和 **`B0`** ，也就是之前指向 `user_id%2=1` 的数据，分裂为 `user_id%4=1` 和 `user_id%4=3`

因为 **`A`** 和 **`A0`** 库的数据相同， **`B`** 和 **`B0`** 数据相同，所以此时无需做数据迁移即可。只需要变更一下分片配置即可，通过配置中心更新，无需重启。
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/JavaLearning/数据库/分库分表概念/取模的方式水平分库扩容-升级从库结束.png)
</center>

由于之前`user_id%2`的数据分配在`2`个库里面，此时分散到`4`个库中，由于老数据还存在（`user_id%4=0`,还有一半`user_id%4=2`的数据），所以需要对冗余数据做一次清理。  

而这个清理，不会影响线上数据的一致性，可是随时随地进行。  
**处理完成以后，为保证高可用，以及下一步扩容需求。可以为现有的主库再次分配一个从库。**
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/JavaLearning/数据库/分库分表概念/取模的方式水平分库扩容-升级从库结束2.png)
</center>

**升级从库完整步骤如下：**  
1. 修改分片配置，做好新库和老库的映射
3. 同步配置，从库升级为主库
4. 解除主从关系
5. 冗余数据清理
6. 为新的数据节点搭建新的从库

### 3. 双写迁移
双写的方案，更多的是针对线上数据库迁移来用的，当然了，对于分库的扩展来说也是要迁移数据的，因此，也可以来协助分库扩容的问题。  
原理和**升级从库**相同，做分裂扩容，只是数据的同步方式不同了。

#### 完整步骤如下：  
**1.增加新库写链接**  
**双写的核心原理，就是对需要扩容的数据库上，增加新库，并对现有的分片上增加写链接，同时写`两份`数据。**  
因为新库的数据为空，所以数据的`CRUD`对其没有影响，在上层的逻辑层，还是以 **老库** 的数据为主。  
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/JavaLearning/数据库/分库分表概念/取模的方式水平分库扩容-双写迁移1.png)
</center>

**2.新老库数据迁移**  
通过工具，把 **老库** 的数据迁移到 **新库** 里面，此时可以选择同步分裂后的数据（`1/2`）来同步；也可以全同步，一般建议全同步，最终做数据校检的时候好处理。
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/JavaLearning/数据库/分库分表概念/取模的方式水平分库扩容-双写迁移2.png)
</center>

**3.数据校检**  
**按照理想环境情况下，数据迁移之后，因为是`双写`操作，所以两边的数据是一致的，特别是`insert`和`update`，一致性情况很高。**

但真实环境中会有网络延迟等情况，对于`delete`情况并不是很理想；  
比如：  
**`A库`** 删除`数据a`的时候，`数据a`正在迁移，还没有写入到 **`C库`** 中，此时 **`C库`** 的删除操作已经执行了， **`C库`** 会多出一条数据。  
此时就需要做好数据校检了，数据校检可以多做几遍，直到数据几乎一致，尽量以 **旧库** 的数据为准。

**4.分片配置修改**  
数据同步完毕，就可以把 **新库** 的分片映射重新处理了，还是按照 **老库** 分裂的方式来进行。  
* `user_id%2=0`，变为`user_id%4=0` 和 `user_id%4=2`  
* `user_id%2=1`，变为`user_id%4=1` 和 `user_id%4=3`

<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/JavaLearning/数据库/分库分表概念/取模的方式水平分库扩容-双写迁移3.png)
</center>

## 五、总结
分库分表可能出现的问题：
1. **添加时主键唯一性的问题：**  
分离之后多张表，就会导致原有的自增长主键不唯一，所以没有办法自增长了；导致业务出现问题，解决方案的也是有的，比如单独维护一张主键表专门用来存放当前主键，或者说用别的中间件等。

2. **新增时的效率问题：**  
虽然不是个大问题，但是新增肯定会多了计算量嘛，这个问题可以忽略不计。

3. **复杂查询：**  
分离成多张表之后，复杂查询可能操作的不仅仅是一个库，这也需要考虑到不同的分离方式用不同的解决方案。

4. **事务问题：**  
多张表需要使用`分布式事务`才能完成原来带有事务的操作。因为原来的事务只是锁一张表现在可能要锁多张表。

5. **扩展性问题：**  
有的切分策略下，对数据的扩展性并不友好，之后如果有更多的数据来了，还需要优化扩展方案。