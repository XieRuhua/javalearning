# MySql索引

[参考文档链接1：一口气搞懂 MySQL 索引所有知识点](https://mp.weixin.qq.com/s/rS-zbxX2P_1-r0jE8HZQjw)  
[参考文档链接2：Mysql索引整理总结](https://blog.csdn.net/u010648555/article/details/81102957)  
[参考文档链接3：MYSQL-索引](https://segmentfault.com/a/1190000003072424)  
[参考文档链接4：一文搞懂MySQL索引（清晰明了）](https://blog.csdn.net/wangfeijiu/article/details/113409719)  
[参考文档链接5：MySQL索引底层实现原理](https://www.cnblogs.com/boothsun/p/8970952.html)  
[参考文档链接6：平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了](https://zhuanlan.zhihu.com/p/27700617)  


[toc]
## 一、概念
### 1. 索引是什么？
**官方介绍索引是帮助`MySQL`高效获取数据的数据结构。**  
索引在`MySQL`中也叫是一种 **“键”** ，是存储引擎用于快速找到记录的一种数据结构，是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。  

**索引优化应该是对查询性能优化最有效的手段了。**如果不使用索引，`MYSQL`必须从第一条记录开始然后读完整个表直到找出相关的行。表越大，花费的时间越多。

**更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。**  
**我们通常所说的索引，包括`聚集索引`、`覆盖索引`、`组合索引`、`前缀索引`、`唯一索引`等，没有特别说明，<font color="red">默认都是使用B+树结构组织</font>（多路搜索树，并不一定是二叉的）的索引。**

### 2. 为什么要有索引?  
一般的应用系统， **读写比例** 在`10:1`左右，而且插入操作和一般的更新操作很少出现性能问题；在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。

### 3. 索引的优缺点
#### 优点
* 索引大大减小了服务器需要扫描的数据量，降低数据排序的成本，降低了`CPU`的消耗
* 索引可以帮助服务器避免排序和临时表
* 索引可以提高数据检索的效率，降低数据库的IO成本，将`随机IO`变成`顺序IO`
* 建立索引可以加快表与表之间的连接
* 为用来对排序（`order by`）或者是分组（`group by`）的字段添加索引可以加快分组或排序

#### 缺点
* 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行`INSERT`、`UPDATE`和`DELETE`，**因为更新表时，`MySQL`不仅要更新保存数据，还要更新保存索引文件**。  
因此应该只为最经常查询和最经常排序的数据列建立索引。
* 建立索引会创建占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。
* 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
* 对于非常小的表，大部分情况下简单的全表扫描更高效。
* 索引只是提高效率的一个因素，如果你的`MySQL`有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。

### 4. 索引文件的存储位置
索引是占据物理空间的，在不同的存储引擎中，索引存在的文件也不同。存储引擎是基于表的，以下分别使用MyISAM和InnoDB存储引擎建立两张表。  
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/数据库/MySql/MySql索引/MySQL表文件组成.png)
</center>

**存储引擎为`MyISAM`时：**  
* `*.frm`：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等
* `*.MYD`：`MyISAM DATA`，用于存储`MyISAM表`的 **数据** 
* `*.MYI`：`MyISAM INDEX`，用于存储`MyISAM表`的 **索引** 相关信息

**存储引擎为`InnoDB`时：**  
* `*.frm`：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等
* `*.ibd`：`InnoDB DATA`， **表数据** 和 **索引** 的文件。该表的`索引(B+树)`的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据

### 5. 索引的查看与删除
**查看**
```sql
-- 查看:
show indexes from `表名`;
-- 或
show keys from `表名`;
```
打印的数据项解释：  
* `Table`：表的名称。
* `Non_unique`：如果索引不能包括重复词，则为`0`。如果可以，则为`1`。
* `Key_name`：索引的名称。
* `Seq_in_index`：索引中的列序列号，从`1`开始。
* `Column_name`：列名称。
* `Collation`：列以什么方式存储在索引中。在`MySQL`中，有值`‘A’（升序）`或`NULL（无分类）`。
* `Cardinality`：索引中唯一值的数目的估计值。通过运行`ANALYZE TABLE`或`myisamchk -a`可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，`MySQL`使用该索引的机会就越大。
* `Sub_part`：如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为`NULL`。
* `Packed`：指示关键字如何被压缩。如果没有被压缩，则为`NULL`。
* `Null`：如果列含有`NULL`，则含有`YES`。如果没有，则该列含有`NO`。
* `Index_type`：用过的索引方法（`BTREE`, `FULLTEXT`, `HASH`, `RTREE`）。
* `Comment`：更多评注。

**删除**
```sql
-- 删除
alter table `表名` drop index 索引名;
```

### 6. 补充：explain
使用`EXPLAIN`关键字来查看一个`SQL`语句的执行计划，从而知道`MySQL`是如何处理`SQL`语句。

#### 6.1 使用方式
```sql
mysql> explain select * from student;
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | student | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
```
`expain`出来的信息有`12`列  
**概要说明：**
1. `id`：选择标识符
2. `select_type`：表示查询的类型
3. `table`：输出结果集的表
4. `type`：表示表的连接类型
5. `possible_keys`：表示查询时，可能使用的索引
6. `key`：表示实际使用的索引
7. `key_len`：索引字段的长度
8. `ref`：列与索引的比较
9. `rows`：扫描出的行数(估算的行数)
10. `Extra`：执行情况的描述和说明

#### 6.2 字段详解
1. **`id`：`SELECT`识别符。** 这是`SELECT`的查询序列号，即`SQL`执行的顺序的标识，`SQL`从大到小的执行。
	* `id`相同时，执行顺序由上至下
	* 如果是子查询，`id`的序号会递增，`id`值越大优先级越高，越先被执行
	* `id`如果相同，可以认为是一组，从上往下顺序执行；在所有组中，`id`值越大，优先级越高，越先执行
2. **`select_type`：示查询中每个`select子句`的类型。**
	* `SIMPLE`：简单SELECT，不使用UNION或子查询等
	* `PRIMARY`：子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY
	* `UNION`：UNION中的第二个或后面的SELECT语句
	* `DEPENDENT UNION`：UNION中的第二个或后面的SELECT语句，取决于外面的查询
	* `UNION RESULT`：UNION的结果，union语句中第二个select开始后面所有select
	* `SUBQUERY`：子查询中的第一个SELECT，结果不依赖于外部查询
	* `DEPENDENT SUBQUERY`：子查询中的第一个SELECT，结果依赖于外部查询
	* `DERIVED`：派生表的SELECT, FROM子句的子查询
	* `UNCACHEABLE SUBQUERY`：一个子查询的结果不能被缓存，必须重新评估外链接的第一行
3. **`table`：** 显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称（别名）
4. **`type`：对表访问方式，表示MySQL在表中找到所需行的方式，又称`“访问类型”`。**  
常用的类型有： **ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）**
	* `ALL`：Full Table Scan， MySQL将遍历全表以找到匹配的行
	* `index`: Full Index Scan，index与ALL区别为index类型只遍历索引树
	* `range`：只检索给定范围的行，使用一个索引来选择行
	* `ref`: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
	* `eq_ref`: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件
	* `const`、`system`: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system
	* `NULL`: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。
5. **`possible_keys`：** 指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 `null`）
	该列完全独立于`EXPLAIN`输出所示的表的次序。这意味着在`possible_keys`中的某些键实际上不能按生成的表次序使用。  
	如果该列是`NULL`，则没有相关的索引。在这种情况下，可以通过检查`WHERE子句`看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用`EXPLAIN`检查查询
6. **`Key`：显示MySQL实际决定使用的键（索引），必然包含在`possible_keys`中。** 如果没有选择索引，键是NULL。  
	要想强制MySQL使用或忽视`possible_keys`列中的索引，在查询中使用`FORCE INDEX`、`USE INDEX`或者`IGNORE INDEX`。
7. **`key_len`：表示索引中使用的字节数。** 可通过该列计算查询中使用的索引的长度（`key_len`显示的值为索引字段的最大可能长度，并非实际使用长度，即`key_len`是根据表定义计算而得，不是通过表内检索出的）  
	**不损失精确性的情况下，长度越短越好** 
8. **`ref`：** 列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
9. **`rows`：** 估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数
10. **`Extra`：该列包含MySQL解决查询的详细信息。** 有以下几种情况：
	* `Using where`：不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤
	* `Using temporary`：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 `group by`、`order by`
	* `Using filesort`：当Query中包含 `order by` 操作，而且无法利用索引完成的排序操作称为`“文件排序”`
	* `Using join buffer`：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。
	* `Impossible where`：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。
	* `Select tables optimized away`：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行
	* `No tables used`：Query语句中使用`from dual` 或不含任何`from`子句

#### 6.3 总结：
* `EXPLAIN`不会告诉你关于 **触发器** 、 **存储过程** 的信息或 **用户自定义函数** 对查询的影响情况
* `EXPLAIN`不考虑各种`Cache`
* `EXPLAIN`不能显示MySQL在执行查询时所作的优化工作
* 部分统计信息是估算的，并非精确值
* `EXPALIN`只能解释`SELECT`操作，其他操作要重写为`SELECT`后查看执行计划。

## 二、索引的类型
### 1. 逻辑分类
#### 普通索引 INDEX  
`MySQL`中基本索引类型，没有什么限制，**允许在定义索引的列中插入重复值和空值** 。可以在创建表的时候指定，也可以修改表结构，如：
```sql
ALTER TABLE table_name ADD INDEX index_name (column)
```

#### 唯一索引 UNIQUE
唯一索引列的值必须**唯一**，但 **允许有空值** 。如果是`组合索引`， **则列值的组合必须唯一** 。可以在创建表的时候指定，也可以修改表结构，如：
```sql
ALTER TABLE table_name ADD UNIQUE (column)
```

#### 主键索引 PRIMARY KEY 
它是一种特殊的 **唯一索引** ， **不允许有空值** 。一般是在建表的时候同时创建主键索引。
当然也可以用 `ALTER` 命令。 **<font color="red">一个表只能有一个主键（联合主键）。</font>** 

**<font color="red">注意：如果没有显式定义，则`mysql`系统会自动选择一个可以唯一标识数据记录的列作为`主键`；如果不存在这种列，则`mysql`会自动为`innodb`表生成一个隐含字段作为主键，这字段的长度为`6个字节`，类型为`长整型`。</font>**

#### 全文索引 FULLTEXT 
只能在文本类型`CHAR`、`VARCHAR`、`TEXT`类型字段上创建全文索引。  
**字段长度比较大时，如果创建`普通索引`，在进行`like`模糊查询时效率比较低，这时可以创建全文索引。`MyISAM`和`InnoDB`（MySQL5.6+版本）中都可以使用全文索引。**  
全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用分词技术等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。

可以在创建表的时候指定，也可以修改表结构，如：
```sql
ALTER TABLE table_name ADD FULLTEXT (column)
```

#### 空间索引
`MySQL`在`5.7`之后的版本支持了`空间索引`，而且支持`OpenGIS`几何数据模型。`MySQL`在空间索引这方面遵循`OpenGIS`几何数据模型规则。[参考链接：Mysql空间索引](https://www.jianshu.com/p/74a554ff973a)

#### 前缀索引
在文本类型如`CHAR`、`VARCHAR`、`TEXT`类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。[参考链接：MySQL 前缀索引](https://www.cnblogs.com/niuben/p/13188277.html)

#### 其他索引（按照索引列数量分类）
* 单列索引（普通索引）
* 组合索引（多列索引、联合索引）：即一个索引包含多个列  

组合索引可以在创建表的时候指定，也可以修改表结构，如：
```sql
ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3)
```

**补充：为什么要使用组合索引**
* **减少开销：**  
	建一个联合索引`(col1,col2,col3)`，实际相当于建了`(col1)`,`(col1,col2)`,`(col1,col2,col3)`三个索引。如果建立普通索引，每多一个索引，都会增加写操作的开销和磁盘空间的开销。   
	**对于大量数据的表，一般情况下在条件允许的情况下使用组合索引替代多个单列索引使用** 。使用联合索引会大大的减少开销！
* **覆盖索引：**  
	对于联合索引`(col1,col2,col3)`，如果有如下sql： **`select col1,col2,col3 from test where col1=1 and col2=2`** 。那么MySQL可以直接通过遍历索引取得数据，而无需<font color="red">回表(后续会讲到)</font>，这减少了很多的随机io操作。  
	减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，<font color="red">覆盖索引(后续会讲到)</font>是主要的提升性能的优化手段之一。
* **效率高：** 
	索引列越多，通过索引筛选出的数据越少。假设有`1000W`条数据的表，有如下sql： **`select from table where col1=1 and col2=2 and col3=3`** ；  
假设每个条件可以筛选出`10%`的数据，如果只有单列索引，那么先通过该索引能筛选出`1000W10%=100w`条数据，然后再回表从`100w`条数据中找到符合`col2=2 and col3= 3`的数据，然后依次获取；  
	**如果是联合索引，通过索引直接筛选出`1000w10% * 10% * 10%=1w`，效率提升可想而知！**

**注意：组合索引的使用，需要遵循`最左前缀匹配原则`  
<font color="red">`最左匹配原则`：即最左优先，在检索数据时从联合索引的最左边开始匹配，组合索引的第一个字段必须出现在查询组句中，这个索引才会被用到。</font>**   
```sql
-- 例如某表t现有索引(a,b,c)，现在有如下语句：
select * from t where a=1 and b=1 and c=1;  -- a、b、c都可以命中索引
select * from t where c=1 and b=1 and a=1;  -- a、b、c都可以命中索引（=和in可以乱序）
select * from t where a=1 and b=1;          -- a、b都可以命中索引
select * from t where a=1;                  -- a可以命中索引

select * from t where a=1 and c=1;          -- a可以命中组合索引，c不可以
select * from t where b=1 and c=1;          -- b、c都不可以命中索引
select * from t where a=1 and b>1 and c=1;  -- a可以命中组合索引，b、c都不可以命中索引
```
**`mysql`会一直向右匹配直到遇到范围查询(`>`、`<`、`between`、`like`)就停止匹配**  
而`=`和`in`可以乱序，比如上述语句`select * from t where c=1 and b=1 and a=1;`在建立`(a,b,c)`索引的情况可以任意顺序，`mysql`的查询优化器会帮你优化成索引可以识别的形式。

### 2. 物理分类
分为`聚簇索引`和`非聚簇索引`（非聚簇索引有时也称辅助索引或二级索引）

#### 聚簇索引（clustered index） 
聚簇是为了提高某个`属性`(或属性组)的查询速度，把这个或这些属性(聚簇码)上具有相同值的元组集中存放在 **连续** 的物理块中。

**不是单独的一种索引类型，而是一种数据存储方式。** 这种存储方式是依靠`B+树`来实现的，根据表的主键构造一棵`B+树`且`B+树`叶子节点存放的都是表的行记录数据时，方可称该主键索引为聚簇索引。 **聚簇索引也可理解为将数据存储与索引放到了一块，找到索引也就找到了数据。**

#### 非聚簇索引（non-clustered index）
**数据和索引是分开的，`B+树`叶子节点存放的不是数据表的行记录。**

**<font color="red">虽然`InnoDB`和`MyISAM`存储引擎都默认使用`B+树`结构存储索引，但是只有`InnoDB`的主键索引才是聚簇索引，`InnoDB`中的其他非主键列以及`MyISAM`的所有列使用的都是`非聚簇索引`。且每张表最多只能拥有一个聚簇索引。</font>**

#### 补充：聚簇索引优缺点 
**优点：**
* 数据访问更快，因为聚簇索引将 **索引** 和 **数据** 都保存在同一个`B+树`中， **因此从聚簇索引中获取数据比非聚簇索引更快**
* 聚簇索引对于主键的排序查找和范围查找速度非常快

**缺点：**
* **插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。** 因此，对于`InnoDB表`，我们一般都会定义一个`自增的ID列`为`主键`（主键列不要选没有意义的自增列，选经常查询的条件列才好，不然无法体现其主键索引性能）
* **更新主键的代价很高，因为将会导致被更新的行移动。** 因此，对于InnoDB表，我们一般定义主键为不可更新。
* **`非聚簇索引`（二级索引）访问需要两次索引查找（这种情况也叫`回表`）** ，第一次找到主键值，第二次根据主键值找到行数据。

## 三、索性的数据结构
**<font color="red">注：此处只大致介绍各种树的概念，其数据结构具体实现和代码参阅其他笔记</font>**
### 1. Hash索引
#### 1.1 概念和原理
`哈希索引`基于哈希表实现，类似`Java`中的`HashMap`、`TreeMap`就是Hash表结构，以键值对的方式存储数据。  
我们使用`Hash表`存储表数据 **`Key`可以存储索引列** ， **`Value`可以存储行记录或者行磁盘地址** 。`Hash表`在等值查询时效率很高，时间复杂度为`O(1)`；但是不支持范围快速查找，范围查找时还是只能通过扫描全表方式。

对于每一行数据，存储引擎都会对所有的索引列计算一个`哈希码`。`哈希索引`将所有的`哈希码`存储在索引中，同时在`哈希表`中保存指向每个数据的`指针`。

**`MySQL`中，只有<font color="red">`Memory`存储引擎显示支持`hash索引`</font>，是`Memory表`的默认索引类型，尽管`Memory表`也可以使用`B-Tree索引`。**   
`Memory`存储引擎支持<font color="red">非唯一hash索引</font>，这在数据库领域是罕见的：**即如果多个值有相同的`hash code`，索引把它们的行指针用链表保存到同一个`hash表`项中。**

**显然这种并不适合作为经常需要查找和范围查找的数据库索引使用，只有精确索引所有列的查询才有效。**

#### 1.2 Hash索引的一些限制
* **`Hash索引`仅仅能满足`=`、`IN`、`<`、`=`、`>`查询，不能使用范围查询。**  
由于 `MySQL`的`Hash索引`比较的是进行 `Hash` 运算之后的 `Hash值`，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 `Hash` 算法处理之后的 `Hash值`的大小关系，并不能保证和`Hash`运算前完全一样。
* **Hash索引无法被用来排序操作。**  
由于`Hash索引`中存放的是经过 `Hash` 计算之后的 `Hash值`，而且Hash值的大小关系并不一定和 `Hash` 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；
* **MySQL Hash索引不能利用部分索引键查询。**  
对于`组合索引`，`Hash索引`在计算 `Hash值` 的时候是组合索引键合并后再一起计算 `Hash值`，而不是 **单独** 计算 `Hash值`，所以通过`组合索引`的前面一个或几个索引键进行查询的时候，`Hash索引`也无法被利用。
* **MySQL Hash索引在任何时候都不能避免表扫描。**  
前面已经知道，`Hash索引`是将索引键通过 `Hash` 运算之后，将 Hash运算结果的 `Hash值`和所对应的行指针信息存放于一个 `Hash表`中，由于不同索引键存在相同 `Hash值`，所以即使取满足某个 `Hash键值`的数据的记录条数，也无法从 `Hash` 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。
* **MySQL Hash索引遇到大量Hash值相等（Hash冲突）的情况后性能并不一定就会比B-Tree索引高。**    
访问`Hash索引`的速度非常快，除非有很多 **哈希冲突** （不同的索引列值却有相同的哈希值）。**当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。**  
如果哈希冲突很多的话，一些索引维护操作的代价也会很高。当从表中删除一行时，存储引擎要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。

**补充：**  
**[官方文档：15.5.3 Adaptive Hash Index](https://dev.mysql.com/doc/refman/8.0/en/innodb-adaptive-hash.html)（自适应哈希索引）**  
`InnoDB引擎`有一个特殊的功能叫做 **`自适应哈希索引`** ，由`Mysql`自动管理，不需要人为干预。默认情况下为开启，我们可以通过参数 **`innodb_adaptive_hash_index`** 来禁用此特性。

**当`InnoDB`注意到某些索引值被使用得非常频繁时，它会在内存中基于缓冲池中的`B-Tree索引`上再创建一个`哈希索引`，这样就让`B-Tree索引`也具有`哈希索引`的一些优点，比如快速的哈希查找。**

### 2. 二叉查找树(BST)
二叉查找树是一种支持数据快速查找的数据结构，如图下所示：

<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/数据库/MySql/MySql索引/二叉查找树.png)
</center>

二叉树特点：每个节点 **最多** 有`2`个分叉，`左子树`和`右子树`数据顺序 **左小右大** 。  
二叉查找树的时间复杂度是 `O(lgn)`，比如针对上面这个二叉树结构，**我们需要计算比较 `3` 次就可以检索到 `id=7` 的数据，相对于直接遍历查询省了一半的时间，从检索效率上看来是能做到高速检索的。**

**此外二叉树的结构能不能解决`哈希索引`不能提供的范围查找功能呢？**  
答案是可以的。观察上面的图，二叉树的叶子节点都是按序排列的，从左到右依次升序排列，如果我们需要找 **`id>5`** 的数据，那我们取出节点为 `6` 的节点以及其右子树就可以了，范围查找也算是比较容易实现。

**但是普通的二叉查找树有个致命缺点：**  
极端情况下会退化为`线性链表`（“树不分叉了”），二分查找也会 **退化为遍历查找** ，**时间复杂退化为 O（N）**，检索性能急剧下降。  
比如以下这个情况，二叉树已经 **极度不平衡** 了，已经退化为**链表**了，检索速度大大降低。此时检索 **`id=7`** 的数据的所需要计算的次数已经变为 `7` 了。
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/数据库/MySql/MySql索引/二叉查找树退化为链表.png)
</center>

在数据库中，数据的自增是一个很常见的形式，比如一个表的主键是 自增`id`（而主键一般默认都是自增的），如果采取二叉树这种数据结构作为索引，那上面介绍到的不平衡状态导致的线性查找的问题必然出现。  
**因此，简单的二叉查找树存在不平衡导致的检索性能降低的问题，是不能直接用于实现 `Mysql` 底层索引的。**

### 3. 平衡二叉树（AVL 树和红黑树）
二叉查找树存在不平衡问题，因此学者提出通过树节点的 **自动旋转** 和调整，让二叉树始终保持基本平衡的状态，就能保持二叉查找树的最佳查找性能了。

平衡二叉树是采用 **二分法** 思维，平衡二叉查找树除了具备二叉树的特点（平衡二叉查找树属于二叉树的子集），最主要的特征是树的左右两个子树的层级最多相差`1`。在插入删除数据时通过`左旋/右旋`操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。  
**使用平衡二叉查找树查询的性能接近于二分查找法，时间复杂度是 `O(log2n)`。**

基于这种思路的自调整平衡状态的二叉树有 **`AVL树`** 和 **`红黑树`** 。

#### 3.1 红黑树（R-B Tree）
`R-B Tree`，全称是`Red-Black Tree`，又称为`红黑树`，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是`红(Red)`或`黑(Black)`。

**红黑树的特性:**
* 每个节点或者是黑色，或者是红色。
* 根节点是黑色。
* 每个`叶子节点（NIL）`是黑色。 （注意：这里叶子节点，是指为空(`NIL`或`NULL`)的叶子节点！）
* 如果一个节点是红色的，则它的子节点必须是黑色的。
* 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

**红黑树是一颗会自动调整树形态的树结构，当二叉树处于一个不平衡状态时，红黑树就会自动`左旋/右旋`节点以及节点变色，调整树的形态，使其保持基本的平衡状态（时间复杂度为 `O(logn)`），也就保证了查找效率不会明显减低。**

比如从 `1` 到 `7` 升序插入数据节点，如果是普通的二叉查找树则会退化成`链表`，但是红黑树则会不断调整树的形态，使其保持基本平衡状态，下面这个红黑树下查找 **`id=7`** 的所要比较的节点数为 **`4`** ，依然保持二叉树不错的查找效率。

红黑树拥有不错的平均查找效率，也不存在极端的 **`O(n)`** 情况，那红黑树作为 `Mysql` 底层索引实现是否可以呢？

其实红黑树也存在一些问题，观察下面这个例子:  
红黑树顺序插入 **`1~7`** 个节点，查找 **`id=7`** 时需要计算的节点数为 **`4`** 。
如下图所示：
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/数据库/MySql/MySql索引/红黑树1.png)
</center>

但是如果我们顺序插入 **`1~16`** 个节点，查找 **`id=16`** 需要比较的节点数为 **`6`** 次。  
观察一下这个树的形态，是不是当数据是顺序插入时，树的形态一直处于 **“右倾”** 的趋势呢？   
**从根本上上看，红黑树并没有完全解决二叉查找树退化成链表的缺点，虽然这个“右倾”趋势远没有二叉查找树退化为线性链表那么夸张，** 但是数据库中的基本主键自增操作，主键一般都是数百万数千万的，如果红黑树存在这种问题，对于查找性能而言也是巨大的消耗，我们数据库不可能忍受这种无意义的等待的。
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/数据库/MySql/MySql索引/红黑树2.png)
</center>

**那么为了解决这种“严重右倾”或者“严重左倾”的情况，就需要考虑另一种更为严格的自平衡二叉树 `AVL树`。<font color="red">因为 `AVL树`是个绝对平衡的二叉树，因此他在调整二叉树的形态上消耗的性能会更多。</font>**

#### 3.2 AVL 树
**注：这里仅介绍`AVL树`的概念和最终效果，调整二叉树使其平衡的代码和实现过程参阅其他笔记**

**`AVL树`本质上还是一棵二叉搜索树，它的特点是：**  
* 本身首先是一棵二叉搜索树。
* 带有平衡条件：每个结点的`左右子树`的 **高度之差的绝对值（平衡因子）** 最多为`1`。

**也就是说`AVL树`本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）。**

如下面的`AVL树`顺序插入 **`1~7`** 个节点，查找 **`id=7`** 所要比较节点的次数为 **`3`** 。  
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/数据库/MySql/MySql索引/AVL树1.png)
</center>

如下面的`AVL树`顺序插入 **`1~16`** 个节点，查找 **`id=16`** 需要比较的节点数为 **`4`** 。从查找效率而言，`AVL树`查找的速度要高于红黑树的查找效率**（`AVL树`是 `4` 次比较，`红黑树`是 `6` 次比较）**。并且从树的形态看来，`AVL树`不存在`红黑树`的 **“右倾”** 问题。  
**也就是说，大量的顺序插入不会导致查询性能的降低，这从根本上解决了红黑树的问题。**
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/数据库/MySql/MySql索引/AVL树2.png)
</center>

**总结一下 AVL 树的优点：**  
* 不错的查找性能（`O（logn）`），不存在极端的低效查找的情况。
* 可以实现范围查找、数据排序。

#### 3.3 平衡二叉树总结
看起来 `AVL树`或者`红黑树`作为数据查找的数据结构确实很不错，但是`AVL树`或者`红黑树`都并不适合做 `Mysql` 数据库的索引数据结构，因为考虑一下这个问题：
- **数据库查询数据的瓶颈在于磁盘 `IO`，如果使用的是平衡二叉树，我们每一个树节点只存储了一个数据，我们一次磁盘 `IO` 只能取出来一个节点上的数据加载到内存里。**  
	结合上面的例子，比如查询 `id=7` 这个数据我们就要进行磁盘 `IO` 三次，这是多么消耗时间的。 所以我们设计数据库索引时需要首先考虑怎么尽可能减少磁盘 `IO` 的次数。  
	**而且平衡二叉树不支持范围查询快速查找，范围查询时需要从根节点多次遍历，查询效率不高。**

- **如果将`AVL树`，`红黑树`直接存储到磁盘上，然后用来检索可以吗？**  
	答案是可以的，但问题是基于磁盘寻道查询比基于内存慢太多了。
	举个例子，假设现在有`100万`数据分布在`红黑树`里面，按照`红黑树`的平均查找性能`O（logN）`来计算，在`N=100万`时，检索任意数据平均需要`20次`查询，如果是在内存完全没问题；  
	**但此时`红黑树`是如果存在磁盘上，那就完全不一样了，按照普通硬盘或者文件系统，每次查询`IO`一次总耗时约`10毫秒`计算，那么在百万级别的数据量下，检索一次数据就需要`10*20`，大概就是`0.2秒`，假如现在数据量扩大`100`倍，数据总量是`一亿`，那么检索一次数据就需要`20秒`，** 这个性能是完全不能接受的，可以想象在这种情况下，使用二叉树是不合适的。

**因此我们可以在一个树节点上尽可能多地存储数据，且减少树的高度，<font color="red">一次磁盘 `IO` 就多加载点数据到内存，这就是 `B 树`、`B+树`的的基本设计原理了。</font>**

### 4. B树（改造二叉树）
#### 4.1 概念和简介
`B树`和`平衡二叉树`稍有不同的是`B树`属于`多叉树`又名`平衡多路查找树`（查找路径不只两个），**数据库索引技术里大量使用者`B树`和`B+树`的数据结构。**

`MySQL`的数据是存储在磁盘文件中的，查询处理数据时，需要先把磁盘中的数据加载到内存中，磁盘`IO` 操作非常耗时，所以我们优化的重点就是尽量减少磁盘 `IO` 操作。**访问`二叉树`的每个节点就会发生一次`IO`，如果想要减少磁盘`IO`操作，就需要尽量降低树的`高度`。** 

因为在`MySQL`的`InnoDB存储引擎`一次`IO`会读取的一页（默认一页`16K`）的数据量，而二叉树一次`IO`有效数据量只有`16字节`，空间利用率极低。  
为了最大化利用一次`IO`空间，一个简单的想法是 **在每个节点存储多个元素，在每个节点尽可能多的存储数据。**  每个节点可以存储`1000`个索引（`16k/16=1000`），**这样就将`二叉树`改造成了`多叉树`** ，通过增加树的叉树<font color="red">**将树从`高瘦`变为`矮胖`**</font>。  
**此时构建`1百万`条数据，树的高度只需要`2层`就可以（`1000*1000=1百万`），也就是说至多只需要`2次`磁盘`IO`就可以查询到数据。磁盘`IO`次数变少了，查询数据的效率自然也就提高了。**

#### 4.2 主要性质和特点
**性质：**  
假如当前有一颗`m阶`的`B树`（<font color="red">**注意阶的意思是指每个`节点`的`孩子节点`的个数，而不是`树层数`**</font>），那么其符合：
1. 每个节点最多有`m`个子节点
2. 除了根节点和叶子节点之外，**其他的每个节点最少有`m/2`（向上取整）个孩子节点**
3. 根节点至少有两个孩子节点，（除了第一次插入的时候，此时只有一个节点，根节点同时是叶子节点）
4. 所有的叶子节点都在同一层
5. 有k个子节点的父节点包含`k-1`个关键码

**特点：**
* `B树`把值接近的相关记录放在同一个磁盘页中，从而利用了访问的局部性原理。
* `父节点`当中的元素不会出现在`子节点`中。
* **多元素、多分叉：** `B树`的节点中存储着多个元素，每个内节点有多个分叉。  
* **排序方式：** 节点中的元素包含键值和数据，节点中的键值遵循`左小右大`排列的原则。也就是说，在所有的节点都储存数据。
* **子节点数：** `非叶节点`的`子节点数>1`，且`<=M` ，且`M>=2`，空树除外（注：`M阶`代表一个树节点最多有多少个查找路径，`M=M路`，当`M=2`则表示是`2叉树`、`M=3则是3叉树`）；
* **关键字数：** 枝节点的关键字数量大于等于`ceil(m/2)-1`个且小于等于`M-1`个（注：`ceil()`是个朝正无穷方向取整的函数 如`ceil(1.1)`结果为`2`)；
* 所有`叶子节点`均在同一层（具有相同的深度，每次查询次数相同，速度稳定）、`叶子节点`除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为`null`（即`叶子节点`之间没有`指针`连接），对应下图最后一层节点的空格子（灰色的指针）;

<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/数据库/MySql/MySql索引/B树.png)
</center>

**总结来说，B树用作数据库索引有以下优点：**
* 优秀检索速度，时间复杂度：`B树`的查找性能等于 `O（h*logm）`，其中 `h` 为 **树高** ，`m` 为每个 **节点关键词** 的个数（`阶数`）；
* 尽可能少的磁盘 `IO`，加快了检索速度；
* 可以支持范围查找。

**看到这里一定觉得B树就很理想了，但是依然存在可以优化的地方：**
* **`B树`不支持范围查询的快速查找** ，想要查找`9`和`29`之间的数据，查找到`9`之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。
* 如果`data`存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘`IO`次数就会变多。

### 5. B+树（改造B树）
**实测网站：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html**

#### 5.1 概念和简介
`B+树`，作为`B树`的升级版，`MySQL`在`B树`的基础上继续改造，相对于`B树`来说`B+树`更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于`二分法查找`。

**使用B+树构建索引。B+树和B树最主要的区别在于非叶子节点是否存储数据的问题**
* `B树`：`非叶子节点`和`叶子节点` **都会存储数据** 。
* `B+树`： **只有** `叶子节点` **才会存储数据** ，`非叶子节点` **只存储键值** 。`叶子节点`之间使用`双向指针`连接，最底层的叶子节点形成了一个 **`双向有序链表`** 。
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/数据库/MySql/MySql索引/B+树.png)
</center>

`B+树`的`最底层叶子节点`包含了 **所有** 的`索引`项。  
从图上可以看到，`B+树`在查找数据的时候，由于数据都存放在`最底层的叶子节点`上，所以每次查找都需要检索到`最底层的叶子节点`才能查询到数据。

所以在需要查询数据的情况下每次的磁盘的`IO`跟树高有直接的关系，但是从另一方面来说，由于数据都被放到了`最底层的叶子节点`，放索引的磁盘块锁存放的索引数量是会跟这增加的，相对于`B树`来说，`B+树`的树高理论上情况下是比`B树`要 **矮** 的。

#### 5.2 特性
* `非叶子节点`不保存关键字记录的指针
* `非叶子节点`只进行数据索引，不存储数据
* `根节点`关键字数量和其`子节点`个数相等
* `叶子节点`保存`父节点`的所有关键字和关键字记录的指针

`B树`相对于`B+树`的优点是：如果经常访问的数据离根节点很近，而`B树`的`非叶子节点`本身存有关键字其数据的地址，所以这种数据检索的时候会要比`B+树`快。

#### 5.3 B 树和 B+树的区别
* **`B树`每一个`节点`里存的都是数据，而 B+树存储的是索引（地址）：** `B树`里一个节点存不了很多个数据，并且 `B+树`一个节点能存很多索引，`B+树` `叶子节点`存所有的数据。
* **`B+树`查询速度更稳定：** `B+数`所有关键字数据地址都存在`叶子节点`上，所以每次查找的次数都相同所以查询速度要比`B树`更稳定;
* **`B+树`的`叶子节点`是数据阶段用了一个`双向的有序链表`串联起来，便于`范围查找`以及`排序`功能。** 
* 当经常访问的数据离根节点很近，而`B树`的`非叶子节点`本身存有关键字其数据的地址，所以这种数据检索的时候会要比`B+树`快。
* **`B+树`的层级更少：** 相较于`B树` `B+数`的每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；
* **`B+树`全节点遍历更快：** `B+树`遍历整棵树只需要遍历所有的`叶子节点`即可，，而不需要像`B树`一样需要对每一层进行遍历，这有利于数据库做全表扫描。

**小结：**  
- `B+树`的`非叶子节点节点`存储的是索引，在单个节点存储容量有限的情况下，单节点也能存储大量索引，使得整个 `B+树`高度降低，减少了磁盘 `IO`。    
- `B+树`的`叶子节点`是真正数据存储的地方，`叶子节点`用了`双向的有序链表`连接起来，这个链表本身就是有序的，在数据范围查找时，更具备效率。  

### 6. 索引最终选择B+树的原因
1. `hash`很快，但每次`IO`只能取一个数
2. `AVL`和`红黑树`在大量数据的情况下，`IO`操作还是太多
3. `B树`每个节点内存储的是数据，因此每个节点存储的分支太少
4. `B+树`节点存储的是 **`索引`+`指针`** (引用指向下一个节点)，可以存储大量索引，同时最终数据存储在叶子节点，并且有引用`双向的有序链表`，可以在`2-3`次的`IO`操作内完成`千万级别`的表操作。

**因此 `Mysql` 的索引用的就是 `B+树`，`B+树`在查找效率、范围查找中都有着非常不错的性能。**  
**<font color="red">建议索引是是`自增长数字`，这样更适合范围查找和排序</font>**

## 四、索引的实现原理
### 1. 基本原理
**索引的目的在于提高查询效率，** 与我们查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小节，然后找到页数。相似的例子还有：查字典、查火车车次、飞机航班等

**<font color="red">本质都是：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，可以总是用同一种查找方式来锁定数据。</font>**

数据库也是一样，但显然要复杂的多，因为不仅面临着`等值查询`(`=`)，还有 **`范围查询`(`>`、`<`、`between`、`in`)、`模糊查询`(`like`)、`并集查询`(`or`)等等。**  
一方面数据是保存在磁盘上的，另外一方面为了提高性能；每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以`简单的搜索树`难以满足复杂的应用场景。

### 2. MyIsam引擎的索引原理
**`MyISAM引擎`的底层实现（`非聚集索引`方式）**  
`MyISAM` 用的是`非聚集索引`方式，即数据和索引落在 **不同的两个文件上** 。`MyISAM` 在建表时以主键作为 `KEY` 来建立`主索引B+树`，树的`叶子节点`存的是对应数据的`物理地址`。我们拿到这个`物理地址`后，就可以到 `MyISAM` 数据文件中直接定位到具体的数据记录了。

**当我们为某个字段添加索引时，我们同样会生成对应字段的索引树，该字段的索引树的叶子节点同样是记录了对应数据的物理地址，然后也是拿着这个物理地址去数据文件里定位到具体的数据记录。**

### 3. InnoDB引擎的索引原理
**`Innodb引擎`的底层实现（`聚集索引`方式）**  
`InnoDB` 是`聚集索引`方式，因此数据和索引都存储在 **同一个文件里**。首先 `InnoDB` 会根据`主键ID` 作为 `KEY` 建立`索引B+树`，而 `B+树`的`叶子节点`存储的是`主键ID` 对应的数据，直接取出来就行了。

**这是建表的时候 `InnoDB` 就会自动建立好`主键ID` （主键索引）索引树，这也是为什么 `Mysql` 在建表时要求必须指定主键的原因。**  
**<font color="red">注意：如果没有显式定义，则`mysql`系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则`mysql`会自动为`innodb表`生成一个隐含字段作为主键，这字段的长度为`6个字节`，类型为`长整型`。</font>**

**当我们为表里某个字段加索引时 `InnoDB` 会怎么建立`索引树`呢？**  
比如我们要给 `user_name` 这个字段加索引，那么 `InnoDB` 就会建立 `user_name` `索引B+树`， **节点里存的是 `user_name` 这个 `KEY`，叶子节点存储的数据的是`主键KEY`。  
<font color="red">注意：叶子存储的是`主键KEY`！</font>拿到`主键KEY` 后，`InnoDB` 才会去主键索引树里根据刚在 `user_name` `索引树`找到的`主键KEY` 查找到对应的数据。**

**问题来了，为什么 `InnoDB` 只在主键索引树的叶子节点存储了具体数据，但是其他索引树却不存具体数据呢，而要多此一举先找到主键，再在主键索引树找到对应的数据呢?**  
**其实很简单，因为 `InnoDB` 需要节省存储空间。** 一个表里可能有很多个索引，`InnoDB` 都会给每个加了索引的字段生成索引树，如果每个字段的索引树都存储了具体数据，那么这个表的索引数据文件就变得非常巨大（数据极度冗余了）。  
从节约磁盘空间的角度来说，真的没有必要每个字段索引树都存具体数据，通过这种看似 **“多此一举”** 的步骤，在牺牲较少查询的性能下节省了巨大的磁盘空间，这是非常有值得的。

### 4. InnoDB 和 MyISAM 引擎索引实现对比小结
在进行 `InnoDB` 和 `MyISAM` 实现原理对比可以看出`MyISAM` 查询性能更好，从上面索引文件数据文件的设计来看也可以看出原因：  
**`MyISAM` 直接找到物理地址后就可以直接定位到数据记录，但是 `InnoDB` 查询到叶子节点后，还需要再查询一次主键索引树，才可以定位到具体数据。**  

**<font color="red">简单理解为`MyISAM` 一步就查到了数据，但是 `InnoDB` 要两步（先找到主键KEY，在找到对应的数据），因此`MyISAM` 查询性能更高。</font>**

## 五、使用索引的注意事项
索引是建立在数据库表中的某些列的上面。因此，在创建索引的时候，应该仔细考虑在哪些列上可以创建索引，在哪些列上不能创建索引。

### 1. 应该创建索引的列
* 在经常需要搜索的列上，可以加快搜索的速度
* 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构
* 在经常用在连接（`JOIN`）的列上，这些列主要是一外键，可以加快连接的速度
* 在经常需要根据范围（`<`，`<=`，`=`，`>`，`>=`，`BETWEEN`，`IN`）进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的
* 在经常需要排序（`order by`）的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
* 在经常使用在`WHERE`子句中的列上面创建索引，加快条件的判断速度
* 尽量选择 **区分度高** 的列作为索引，**区分度的公式是`count(distinct col)/count(*)`，** 表示字段不重复的比例，比例越大我们扫描的记录数越少；  
比如**唯一键的区分度是`1`，而一些状态、性别字段可能在大数据面前区分度就是`0`** ，一般需要`join`的字段尽量要求是 **`0.1`** 以上，即平均`1`条扫描`10`条记录
* 对于连续多个`and`的情况，`mysql`会按照`联合索引`，`从左到右`的顺序找一个区分度高的索引字段( **这样便可以快速锁定很小的范围** )，加速查询

### 2. 不该创建索引的列
* 对于那些在查询中很少使用或者参考的列不应该创建索引。
* 若列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
* 对于那些只有很少数据值或者重复值多的列也不应该增加索引。
* 这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。
* 对于那些定义为`text`、`image`、`bit`数据类型的列不应该增加索引。
* 这些列的数据量要么相当大，要么取值很少。
* 当该列修改性能要求远远高于检索性能时，不应该创建索引。（`修改性能`和`检索性能`是互相矛盾的）
* 索引列不能在条件中参与计算， **保持列“干净”** ，**比如`from_unixtime(create_time) = '2014-05-29'`就不能使用到索引，原因很简单，`b+树`中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成`create_time = unix_timestamp('2014-05-29')`**

### 3. 最左前缀匹配原则  
<font color="red">`最左匹配原则`：即最左优先，在检索数据时从联合索引的最左边开始匹配，组合索引的第一个字段必须出现在查询组句中，这个索引才会被用到。</font>**   
```sql
-- 例如某表t现有索引(a,b,c)，现在有如下语句：
select * from t where a=1 and b=1 and c=1;  -- a、b、c都可以命中索引
select * from t where c=1 and b=1 and a=1;  -- a、b、c都可以命中索引（=和in可以乱序）
select * from t where a=1 and b=1;          -- a、b都可以命中索引
select * from t where a=1;                  -- a可以命中索引

select * from t where a=1 and c=1;          -- a可以命中组合索引，c不可以
select * from t where b=1 and c=1;          -- b、c都不可以命中索引
select * from t where a=1 and b>1 and c=1;  -- a可以命中组合索引，b、c都不可以命中索引
```
**`mysql`会一直向右匹配直到遇到范围查询(`>`、`<`、`between`、`like`)就停止匹配**  
而`=`和`in`可以乱序，比如上述语句`select * from t where c=1 and b=1 and a=1;`在建立`(a,b,c)`索引的情况可以任意顺序，`mysql`的查询优化器会帮你优化成索引可以识别的形式。


## 六、补充：什么是覆盖索引和回表
在了解覆盖索引和回表之前我们先大概了解一下什么是`聚集索引`（主键索引）和非聚簇索引（辅助索引或二级索引）
* 聚集索引（主键索引）：  
   - 聚集索引就是按照每张表的主键构造一颗`B+树`，同时`叶子节点`中存放的即为整张表的记录数据。  
   - 聚集索引的`叶子节点`称为数据页，聚集索引的这个特性决定了索引组织表中的数据也是索引的一部分。
* 非聚簇索引（辅助索引、二级索引）：  
   非主键索引，`叶子节点 = 键值 + 数据`。`Innodb存储引擎`的书签就是相应行数据的主键索引值。

**如：`(id PK, name KEY, sex);` 其中`id（主键）`为聚集索引，`name`为普通索引**

### 1. 覆盖索引
**什么是覆盖索引？有下面三种理解：**
* **解释一：** `select`的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。
* **解释二：** 索引是高效找到行的一个方法，当仅通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。  
如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做`覆盖索引`。
* **解释三：** 是`非聚集组合索引`的一种形式，它包括在查询里的`Select`、`Join`和`Where子句`用到的所有列（即建立`索引`的字段 **正好** 是覆盖查询语句`[select子句]`与查询条件`[Where子句]`中所涉及的字段，也即索引包含了查询正在查找的所有数据）。

不是所有类型的索引都可以成为`覆盖索引`。  
`覆盖索引` **必须** 要存储索引的列，而`哈希索引`、`空间索引`和`全文索引`等都不存储索引列的值，**所以`MySQL`只能使用`B-Tree索引`做`覆盖索引`**  
使用`覆盖索引`的一个好处是：`辅助索引`不包含整行记录的所有信息，故其大小要远小于`聚集索引`，因此可以减少大量的`IO`操作

**<font color="red">注意：`覆盖索引`技术最早是在`InnoDB Plugin`中完成并实现，这意味着对于`InnoDB`版本小于`1.0`的或者`MySQL`数据库版本为`5.0`以下的，`InnoDB存储引擎`是不支持`覆盖索引`特性</font>**

### 2. 回表
假设`表t`有两个索引：`(id PK, name KEY)`;  
查询如下：
```sql
-- select 1
select * from t where name = 'admin';　
-- select 2
select * from t where id = '1';　
```
两个查询的执行区别：
* **`select 1`：聚集索引，** 直接定位行记录
* **`select 2`：普通索引（非聚集索引），** 需要遍历两次索引树，第一次先通过普通索引定位到id，第二次再通过聚集索引定位到具体的行记录。

这就是所谓的回表查询，先定位主键值，再定位行记录，性能比聚集索引低（进行了`两次IO`操作）。

**避免回表查询？**  
直接使用聚集索引（主键或者第一个唯一索引）即可。

### 3. 总结
**<font color="red">覆盖索引就是为了避免回表操作。</font>**

## 七、总结
### 1. 常用的索引优化方式
#### 1.1 有索引但未被用到的情况
1. **`Like`的参数以通配符开头时**  
	尽量避免`Like`的参数以通配符开头，否则数据库引擎会放弃使用索引而进行全表扫描。  
	**以通配符开头** 的`sql`语句，例如：`select * from t where a like '%***'`，这是全表扫描，没有使用到索引，不建议使用。  
	**不以通配符开头** 的`sql`语句，例如：`select * from t where a like '***%'`，这使用到了索引，是有范围的查找了，比 **以通配符开头** 的sql语句效率提高不少。

2. **`where`条件不符合最左前缀原则时**  
例子已在 "使用索引的注意事项" 的内容中有举例。

3. **使用`！=` 或 `<>` 操作符时**  
尽量避免使用`！=` 或 `<>`操作符，否则数据库引擎会放弃使用索引而进行 **全表扫描** 。使用`>`或`<`会比较高效。

4. **索引列参与计算**  
应尽量 **避免** 在 `where子句`中对字段进行表达式操作，这将导致引擎放弃使用索引而 **进行全表扫描** 。 

5. **对字段进行`null`值判断**  
	应尽量 **避免** 在`where子句`中对字段进行`null`值判断，否则将导致引擎放弃使用索引而 **进行全表扫描** 。
	```sql
	select * from t where a is null ;
	```

	可以在`字段a`上设置默认值`0`，确保表中`字段a`列没有`null`值，然后这样查询：
	```sql
	select * from t where a = 0;
	```

6. **使用`or`来连接条件**  
	应尽量 **避免** 在`where子句`中使用`or`来连接条件，否则将导致引擎放弃使用索引而 **进行全表扫描**：
	```sql
	select * from t where a = '1' or a = '2';
	```

	可以用下面这样的查询代替上面的 `or` 查询：
	```sql
	select from t where a = '1' union all select from t where a = '2';
	```

#### 1.2 避免select * 查询  
在解析的过程中，会将`*` 依次转换成所有的列名，这个工作是通过查询数据字典完成的，这意味着将耗费更多的时间。

**<font color="red">所以，应该养成一个需要什么就取什么的好习惯。</font>**

#### 1.3 order by 语句优化 
**任何在`Order by`语句的`非索引项`或者有`计算表达式`都将降低查询速度。**
* 为所使用的列建立另外一个索引
* 绝对避免在`order by`子句中使用表达式。  

#### 1.4 GROUP BY语句优化
**提高`GROUP BY`语句的效率, 可以通过将不需要的记录在`GROUP BY`之前过滤掉**
```sql
-- 低效查询:
SELECT JOB , AVG(SAL)
FROM EMP
GROUP by JOB
HAVING JOB = ‘PRESIDENT'
OR JOB = 'MANAGER'

-- 高效查询:
SELECT JOB , AVG(SAL)
FROM EMP
WHERE JOB = ‘PRESIDENT'
OR JOB = 'MANAGER'
GROUP by JOB
```

#### 1.5 用 exists 代替 in  
很多时候用 `exists` 代替 `in` 是一个好的选择：
```sql
select num from t1 where num in(select num from t2)
-- 用下面的语句替换：
select num from t1 where exists(select 1 from t2 where num=a.num)
```

#### 1.6 尽可能的使用 varchar/nvarchar 代替 char/nchar   
因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。

#### 1.7 去重时能用DISTINCT的就不用GROUP BY
```sql
SELECT orderId FROM order WHERE price > 10 GROUP BY orderId
-- 可改为：
SELECT DISTINCT orderId FROM order WHERE price > 10
```

#### 1.8 能用UNION ALL就不要用UNION 
`UNION ALL`不执行`SELECT DISTINCT`（结果去重）函数，这样就会减少很多不必要的资源。

#### 1.9 在Join表的时候使用相同类型的例，并将其索引
如果应用程序有很多`JOIN` 查询，你应该确认 **两个表中`Join`的字段是被建过`索引`的** 。  
这样，`MySQL`内部会启动为你优化`Join`的`SQL`语句的机制（注意：这些被用来`Join`的字段 **应该是相同的类型的**）。

例如：  
**如果把 `DECIMAL` 字段和一个 `INT` 字段`Join`在一起，`MySQL`就无法使用它们的索引。  
并且对于那些`STRING`类型，还需要有相同的字符集才行。（两个表的字符集有可能不一样）**

### 2. 索引选择
**索引选择原则：**
1. 较频繁的作为查询条件的字段应该创建索引
2. 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件
3. 不会出现在 WHERE 子句中的字段不该创建索引
4. `更新非常频繁`的字段不适合创建索引  

**当然，并不是存在更新的字段就一定不适合创建索引，从判定策略的用语上也可以看出，是`"非常频繁"`的字段。** 

**到底什么样的更新频率应该算是`"非常频繁"`呢？每秒？每分钟？还是每小时呢？**   
很多时候是通过比较同一时间段内被更新的次数和利用该字段作为条件的查询次数来判断的，如果通过该字段的查询并不是很多，可能几个小时或是更长才会执行一次，更新反而比查询更频繁，那这样的字段肯定不适合创建索引。    
反之，如果我们通过该字段的查询比较频繁，但更新并不是特别多，比如查询几十次或更多才可能会产生一次更新，那么更新所带来的附加成本也是可以接受的。

**性能优化过程中，选择在哪个列上创建`索引`是最非常重要的。**  
可以考虑使用索引的主要有两种类型的列：在`where子句`中出现的列，在`join子句`中出现的列，而不包含在`SELECT关键字`后选择列表的列；

### 3. 索引选择注意事项
**既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？**  
答案是否定的。  
因为索引虽然加快了查询速度，但索引也是有代价的：**索引文件本身要消耗存储空间，同时索引会加重`插入`、`删除`和`修改`记录时的负担；另外，`MySQL`在运行时也要消耗资源维护索引。**

因此不要过度索引，只保持所需的索引。每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能。  
**在修改表的内容时，索引必须进行更新，有时可能需要重构；因此，索引越多，更新数据时所花的时间越长。**