# MyISAM与InnoDB 的区别与联系

[文档内容参考1：MyISAM与InnoDB 的区别（9个不同点）！](https://blog.csdn.net/qq_35642036/article/details/82820178)  
[文档内容参考2：MyISAM与InnoDB两者之间区别与选择，详细总结，性能对比](https://blog.csdn.net/wjtlht928/article/details/46641865)  
[文档内容参考3：InnoDB和MyISAM区别和联系](https://zhuanlan.zhihu.com/p/95949946)

[toc]
## 一、区别
**InnoDB：** MySQL默认的事务型引擎，也是最重要和使用最广泛的存储引擎。它被设计成为大量的短期事务，短期事务大部分情况下是正常提交的，很少被回滚。InnoDB的性能与自动崩溃恢复的特性，使得它在非事务存储需求中也很流行。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑 InnoDB 引擎。
> Innodb引擎的4大特性：插入缓冲（insert buffer），二次写（double write），自适应哈希索引（ahi），预读（read ahead）

**MyISAM：** 在MySQL 5.1 及之前的版本，MyISAM是默认引擎。MyISAM提供的大量的特性，包括全文索引、压缩、空间函数（GIS）等，但MyISAM并不支持事务以及行级锁，而且一个毫无疑问的缺陷是崩溃后无法安全恢复。对于只读的数据，或者表比较小，可以忍受修复操作，则依然可以使用MyISAM（但请不要默认使用MyISAM，而是应该默认使用InnoDB）

### 1. 存储结构
**MyISAM：**  
myisam属于堆表，每个MyISAM在磁盘上存储成三个文件，每个文件名以表名开头，扩展名指出文件类型。  
分别为：表定义文件（**.frm**）用于存储表的定义、数据文件（**.MYD**）用于存放数据、索引文件（**MYI**）用于存放表索引。

**InnoDB：**  
innodb属于索引组织表，innodb有两种存储方式，**共享表空间存储**和**多表空间存储**，两种存储方式的表结构和MyISAM一样，以表名开头，扩展名是**.frm**。  

如果使用共享表空间，那么所有表的数据文件和索引文件都保存在一个表空间里，一个表空间可以有多个文件，通过innodb_data_file_path和innodb_data_home_dir参数设置共享表空间的位置和名字，一般共享表空间的名字叫ibdata1-n。  
如果使用多表空间，那么每个表都有一个表空间文件用于存储每个表的数据和索引，文件名以表名开头，以.ibd为扩展名。

### 2. 存储空间
**MyISAM：**  
MyISAM 支持支持三种不同的存储格式：**静态表（默认，但是注意数据末尾不能有空格，会被去掉）、动态表、压缩表**。当表在创建之后并导入数据之后，不会再进行修改操作，可以使用压缩表，极大的减少磁盘的空间占用。
MyISAM表格可以被压缩后进行查询操作

**InnoDB：**  
需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。  
InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB。

### 3. 可执行、备份和恢复
**MyISAM：** 数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。

**InnoDB：** 免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十 G 的时候就相对痛苦了。

### 4. 事务支持
**MyISAM：** 强调的是性能，每次查询具有原子性，其执行速度比 InnoDB 更快，但是不提供事务支持。

**InnoDB：** 提供事务支持事务，外部键等高级数据库功能。   
具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
```sql
-- 查看mysql的当前使用的事务隔离级别
show global variables like 'tx_isolation';
```  

### 5. 表锁差异
**MyISAM:**  
**MyISAM只支持表级锁**，用户在操作MyISAM表时，**select、update、delete、insert**语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。  
也可以通过lock table命令来锁表，这样操作主要是可以模仿事务，但是消耗非常大，一般只在实验演示中使用。  
**MyISAM是表级锁定的存储引擎，它不会出现死锁问题**

**InnoDB：**  
**支持事务和行级锁**，InnoDB支持行级锁和表级锁默认为行级锁，这是 InnoDB 的最大特色。行锁大幅度提高了多用户并发操作的新能。  
但是 InnoDB 的行锁，只是在语句能够明确用到的索引的时候是有效的，而不是锁在物理行记录上，用非索引或者索引不明确（LIKE、<>等等）的情况下会触发锁表（即如果访问没有命中索引，也无法使用行锁，将要退化为表）。

例如：
```sql
-- innodb引擎中有t_user，仅有一个主键索引uid
t_user(uid, uname, age, sex) innodb;
uid PK;

-- 命中索引，行锁。
update t_user set age=10 where uid=1;
-- 未命中索引，表锁。
update t_user set age=10 where uid != 1;
-- 无索引，表锁。
update t_user set age=10 where name='testName';
```
#### 5.1 表级锁原理：
直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许  

**写操作时：** 如果表上没有锁，在其上面放置一个写锁，否则，把锁定请求放在写锁队列中。  
**读操作时：** 如果表上没有写锁定，那么把一个读锁放在其上面，否则把锁请求放在读锁定队列中

当一个锁定被释放时，表可被写锁定队列中的线程得到，然后才是读锁定队列中的线程。这意味着，如果你在一个表上有许多更新，那么你的SELECT语句将等到所有的写锁定线程执行完才可以执行。

#### 5.2 行级锁原理：
只对指定的行进行锁定，其他进程还是可以对表中的其他行进行操作的。  
行级锁是Mysql粒度最小的一种锁，它能大大的减少数据库操作的冲突，但是粒度越小实现成本也越大。

行级锁可能会导致 **“死锁”**，那到底是怎么导致的呢？  
分析原因：Mysql行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，那么Mysql就会锁定这个主键索引，如果sql语句操作的是非主键索引，那么Mysql会先锁定这个非主键索引，再去锁定主键索引。

在UPDATE 和 DELETE操作时Mysql不仅会锁定所有WHERE 条件扫描过得索引，还会锁定相邻的键值。

**“死锁”举例分析：**  
表Test：（ID,STATE,TIME） 主键索引：ID  非主键索引：STATE

当执行"UPDATE STATE =1011 WHERE STATE=1000" 语句的时候会锁定STATE索引，由于STATE 是非主键索引，所以Mysql还会去请求锁定ID索引

当另一个SQL语句与语句1几乎同时执行时：“UPDATE STATE=1010 WHERE ID=1” ，对于语句2 Mysql会先锁定ID索引，由于语句2操作了STATE字段，所以Mysql还会请求锁定STATE索引。这时。彼此锁定着对方需要的索引，又都在等待对方释放锁定。所以出现了"死锁"的情况。

#### 5.3 行级锁的优缺点
**行级锁优点：**  
有许多线程访问不同的行时，只存在少量的冲突。回滚时只有少量的更改，可以长时间锁定单一的行

**行级锁缺点：**  
* 相对于页级锁和表级锁来说占用了更多的内存
* 当表的大部分行在使用时，比页级锁和表级锁慢，因为你必须获得更多的锁
* 当在大部分数据上经常使用GROUP BY操作，肯定会比表级锁和页级锁明显慢很多
* 用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。

#### 5.4 页级锁
<font color="red">**页级锁：表级锁速度快，但是冲突多；行级锁速度慢，但冲突少；页级锁就是他俩折中的，一次锁定相邻的一组记录。**</font>

Innodb的行锁模式有以下几种：**共享锁，排他锁，意向共享锁(表锁)，意向排他锁(表锁)，间隙锁**。  
<font color="red">**注意：当语句没有使用索引，innodb不能确定操作的行，这个时候就使用的意向锁（意向共享锁、意向排他锁），也就是表锁**</font>

### 6. AUTO_INCREMENT（自动递增）
**MyISAM：**  
可以和其他字段一起建立联合索引，且引擎的自动增长列必须是索引。如果是组合索引，自动增长可以不是第一列，它可以根据前面几列进行排序后递增。

**Innodb：**  
引擎的自动增长列必须是索引且该索引只有该字段，如果是组合索引也必须是组合索引的第一列。

### 7. 全文索引
**MyISAM：** 支持 FULLTEXT类型的全文索引。  
**Innodb：** 不支持FULLTEXT类型的全文索引。  
MySQL 5.6 之前版本，InnoDB 不支持全文索引，只能通过插件变相支持（如：sphinx插件）。但是在 5.6 及以后的版本，MyISAM 和 InnoDB存储引擎均支持全文索引。

### 8.索引的区别
**MyISAM：**  
是非聚集索引，使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。  
在索引数据大于分配的资源时，会由操作系统来cache；数据文件依赖于操作系统的cache。

**Innodb：**   
是聚集索引，同样使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。
但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其索引也都会很大。  
innodb不管是索引还是数据，都是自己来管理。

也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。

<font color="red">**注意：两者索引保存位置不同，MyISAM的索引以表名+.MYI文件分别保存，InnoDB的索引和数据一起保存在表空间里**</font>

### 9. 表的具体行数
**MyISAM：** 保存有表的总行数，如果 select count(*) from table; 会直接取出该值。

**Innodb：** 没有保存表的总行数，如果使用 select count(*) from table 就会遍历整个表，消耗相当大，但是在加了wehre 条件后，myisam和innodb处理的方式都一样。


**那么为什么InnoDB没有了这个变量呢？**  
因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。  
InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB还会尝试去遍历其他聚簇索引。  
如果索引并没有完全处于InnoDB维护的缓冲区（Buffer Pool）中，count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT/DELETE时更新对应的数据。 

和上面提到的问题一样，如果此时存在多个事务的话这种方案也不太好用。  
如果得到大致的行数值已经足够满足需求可以尝试SHOW TABLE STATUS LIKE "tableName"（获取表的信息），其中的rows即为大致的记录数。

### 10. 表主键
**MyISAM：** 允许没有任何索引和主键的表存在，索引都是保存行的地址。


**Innodb：** 如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，innodb的数据是主索引的一部分，附加索引保存的是主索引的值。

### 11. 外键支持
**MyISAM：** 不支持  
**InnoDB：** 支持  
<font color="red">**注意：对一个包含外键的InnoDB表转为MYISAM会失败**</font>

## 二、如何选择
* **MyISAM：** 基于传统的ISAM类型，ISAM是Indexed Sequential Access Method (有索引的顺序访问方法) 的缩写，它是存储记录和文件的标准方法。不是事务安全的，而且不支持外键，如果执行大量的select，insert MyISAM比较适合。

* **InnoDB：** 支持事务安全的引擎，支持外键、行锁、事务是他的最大特点。如果有大量的update和insert，建议使用InnoDB，特别是针对多个并发和QPS较高的情况。

### 1. 是否需要支持事务和外键
你需要事务处理或是外键，那么InnoDB 可能是比较好的方式。  
InnoDB 给 MySQL 提供了具有事务(commit)、回滚(rollback)和崩溃修复能力 (crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。 InnoDB 提供了行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non- locking read in SELECTs)。  
这些特性均提高了多用户并发操作的性能表现。在InnoDB表中不需要扩大锁定 (lock escalation)，因为 InnoDB 的列锁定(row level locks)适宜非常小的空间。  
InnoDB 是 MySQL 上第一个提供外键约束(FOREIGN KEY constraints)的表引擎。


### 2. 数据量是否很大/恢复快慢
数据的大小，是一个影响你选择什么样存储引擎的重要因素，**大尺寸的数据集趋向于选择InnoDB方式**，因为其支持事务处理和故障恢复。数据库的大侠决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。
而MyISAM可能会需要几个小时甚至几天来干这些事，InnoDB只需要几分钟。

**因为MyISAM相对简单所以在效率上要优于InnoDB。小型应用使用MyISAM是不错的选择。**

**InnoDB：**  
> InnoDB 的设计目标是处理大容量数据库系统，为处理巨大数据量时的最大性能设,它的 CPU 利用率是其它基于磁盘的关系数据库引擎所不能比的。  
在技术上，InnoDB 是一套放在 MySQL 后台的完整数据库系统，InnoDB 在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。   
InnoDB 把数据和索引存放在表空间里，可能包含多个文件，这与其它的不一样，举例来说，在 MyISAM 中，表被存放在单独的文件中。InnoDB 表的大小只受限于操作系统的文件大小，一般为 2 GB。  

> InnoDB所有的表都保存在同一个数据文件 **ibdata1** 中（也可能是多个文件，或者是独立的表空间文件）,相对来说比较不好备份，免费的方案可以是**拷贝数据文件、备份 binlog，或者用 mysqldump。**

**MyISAM：**  
> MyISAM 是MySQL缺省存贮引擎。   
每张MyISAM 表被存放在三个文件：**frm 文件存放表格定义、 数据文件是MYD (MYData) 、索引文件是 MYI (MYIndex)**。    
MyISAM表是保存成文件的形式,在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。  

> 对于MyISAM表的恢复：可以使用Mysql自带的myisamchk工具： **myisamchk -r tablename** 或者 **myisamchk -o tablename（比前面的更保险）**

### 3. 读写操作占比
MyISAM引擎的表的查询、更新、插入的效率要比InnoDB高
如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。

### 4. 高并发风险
MyISAM引擎的表在大量高并发的读写下会经常出现表损坏的情况。  

表损坏常见症状：
* 查询表不能返回数据或返回部分数据
* 打开表失败：**Can’t open file: '×××.MYI' (errno: 145)** 
* **Error: Table 'p' is marked as crashed and should be repaired**
* **Incorrect key file for table: '...'. Try to repair it**

## 三、补充

1、可以用 show create table tablename 命令看表的引擎类型。  
2、对不支持事务的表做start/commit操作没有任何效果，在执行commit前已经提交。  
3、可以执行以下命令来切换非事务表到事务（数据不会丢失），innodb表比myisam表更安全：
```sql
alter table tablename type=innodb;
-- 或者使用 
alter table tablename engine = innodb;
```

4、 默认innodb是开启自动提交的，如果你按照myisam的使用方法来编写代码页不会存在错误，只是性能会很低。如何在编写代码时候提高数据库性能呢？
* 对于支持事务的InnoDB类型的表，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动Commit，严重影响了速度。  
可以在执行sql前调用begin，多条sql形成一个事务（即使AUTOCOMMIT打开也可以），避免多次提交导致的数据库开销，将大大提高性能。
* 在一个事务获得排他锁或者意向排他锁以后，如果后面还有需要处理的sql语句，在这两条或者多条sql语句之间程序应尽量少的进行逻辑运算和处理，减少锁的时间。
* 尽量避免**死锁**。
* sql语句如果有where子句一定要使用索引，尽量避免获取意向排他锁。
* 针对我们自己的数据库环境，日志系统是直插入，不修改的，所以我们使用混合引擎方式，**ZION_LOG_DB照旧使用myisam存储引擎，只有ZION_GAME_DB，ZION_LOGIN_DB，DAUM_BILLING使用Innodb引擎。**  

5、InnoDB为什么推荐使用自增ID作为主键？  
自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。

6、大批的inserts 语句在 MyISAM下会快一些，但是updates 在InnoDB下会更快一些——尤其在并发量大的时候。



<font color="red">**MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。**</font>
