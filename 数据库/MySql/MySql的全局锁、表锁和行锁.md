# MySQL 的全局锁、表锁和行锁

[部分官方文档：8.11.2 表锁定问题](https://dev.mysql.com/doc/refman/5.7/en/table-locking.html)  
[部分官方文档：14.7.1 InnoDB 锁定](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html)  

[文档内容参考1：MySQL：全局锁，表锁和行锁](https://blog.csdn.net/sayoko06/article/details/89945410)  
[文档内容参考2：mysql锁——innodb的行级锁](https://www.cnblogs.com/huangfuyuan/p/9510022.html)   
[文档内容参考3：innodb行锁：两阶段锁协议与死锁预防](https://www.jianshu.com/p/614143c9b1d3/)  


数据库为多用户共享的，当出现并发访问的时候，需要使用锁来控制资源的访问。  
根据加锁的范围，MySQL里面的锁大致可以分成**全局锁**、**表级锁**和**行锁**三类。

[toc]
## 一、全局锁

全局锁就是对整个数据库实例加锁。  
MySQL 提供了一个加全局读锁的方法，命令是<font color="red">**Flush tables with read lock（FTWRL）**</font>。

当你需要将整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

主要的使用场景：做全库逻辑备份的时候，为了保证备份期间的库在同一个逻辑时间点，使库处于只读状态，即保证一致性，但是这样子备份会导致很大问题（暂停写入，主从同步延迟）。

真正备份时，需要在可重复读隔离级别下开启一个事务。当逻辑备份**mysqldump**命令使用参数**–single-transaction**时，备份数据之前会启动一个事务，确保拿到一致性视图。而由于MVCC的支持，这个过程中的数据是可以正常更新的。

但是 **–single-transaction** 只适用于**支持事务引擎**的库表。有些引擎是不支持事务的，比如MyISAM，因此只能通过FTWRL加全局锁的方式备份。

### set global readonly=true 方法

**set global readonly=true**方式，也可以让全库进入只读状态，但是仍然推荐FTWRL方式。

1、有些系统中，readonly的值会被用来做其他逻辑，比如判断是主库还是备库。因此，修改global变量的方式影响面更大，不建议使用。

2、异常处理机制上有差异。

- 如果执行FTWRL命令之后由于客户端发生异常断开，MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态；
- 如果将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，会导致整个库长时间处于不可写状态。

### 小结
**不加锁而进行备份的问题可以参考事务的一致性。**

数据库全局锁（只读状态）的危险性：
* 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就能停止。
* 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。

<font color="red">**注 ：业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。**</font>

## 二、表级锁
全局锁就是对整张表加锁。    
MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

### 1. 表锁
表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

举个例子：
```sql
-- 线程A执行以下语句
lock tables T1 read, T2 write;
```
执行到这里时，进入当前线程A：
* T1表仅允许 **线程A** 读，**其他线程** 如需写、更新要**等待线程退出**，**线程A** 如需写、更新会引发mysql报错。
* T2表仅允许 **线程A** 读写更新，**其他线程** 如需写、更新都会被阻塞，需等待空间退出 。
* **线程A**在执行<font color="red">unlock tables</font>之前，也只能执行读T1表、读写T2表的操作。连写T1都不允许，自然也不能访问其他表。

**注意：在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式，而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是很大。**

### 2. 元数据锁（meta data lock，MDL)
当我们有时候在操作表结构修改语句（alert）时，   有时候会出现<font color="red">**Waiting for table metadata lock**</font>报错信息，一般都是进行alter操作时被堵住了，导致了我们在 **show processlist** 查看线程时 时，看到线程的状态是在等 **meta data lock（MDL）**，这就是元数据锁。

MDL 不需要显示使用，在访问一个表的时候就会被自动加上。MDL 的作用是，保证读写的正确性。

场景：如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对应不上，肯定是不行的。

因此在 MySQL 5.5 之后加入了MDL，当对一个表做增删改查操作的时候，加 MDL 读锁，当对表做结构变更操作的时候，加了 MDL 写锁：
* <font color="red">**读锁之间不互斥**</font>，因此你可以有多个线程同时对一张表进行读取操作
* <font color="red">**读写之间、写写之间是互斥的**</font>，用来保证变更结构操作的安全性。因此如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

**虽然 MDL 锁是系统默认加的，但是却不能忽略一个机制，比如下面一个例子：可能会给一个小表加字段，导致整个库都挂了。**  
如：  
当给一个表加字段、或者修改字段、或者加索引，需要扫描全表的数据。对大表操作的时候，需要特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出现问题。    
| session A        | session B        | session C                  | session D        |
| :---------------- | :---------------- | :-------------------------- | :---------------- |
| begin :          |                  |                            |                  |
| select * from T; |                  |                            |                  |
|                  | select * from T; |                            |                  |
|                  |                  | alert T add new_field int; |                  |
|                  |                  |                            | seletc * from T; |
**4个session执行过程：**   
* sessionA 先启动，这个时候会对 T表 加一个 **MDL读锁**
* sessionB 需要的也是 **MDL读锁**，读锁之间不互斥，因此可以正常执行。
* sessionC 执行 **alert** 语句，修改数据库结构，会被阻塞，因为事务中的 **MDL锁** 还没有释放，在语句执行开始时申请，但是语句结束后并不会马上释放，而是等到事务提交之后再释放。所以 sessionA 读锁还没有释放而 sessionC 需要一个写锁，因此只能被阻塞。
*  如果再执行session的select查询语句，虽然是需要 **MDL读锁** ，但是由于第三步sessionC 的 **MDL写锁** 被block住还没有释放，所以sessionD 也申请不到 **MDL读锁**，会被blocked，所以表就会完全变成不可读状态。而恰好 T表 读写比较频繁，而且如果客户端有重试机制，超时之后再重启一个新的 session，这个库的线程很快就会爆满。

<font color="red">**注意：一般行锁都有锁超时时间。但是MDL锁没有超时时间的限制，只要事务没有提交就会一直锁住。**</font>

#### 安全的给表加字段：
首先要解决长事务，事务不提交，就会一直占着 MDL 锁， 在 MySQL 的 <font color="red">**information_schema**</font> 库的 <font color="red">**innodb_trx**</font> 表中，你可以查看当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，<font color="red">**要考虑先暂停 DDL，或者 kill 掉这个长事务**</font>。

但考虑一下这个场景： 如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，你不得不加字段，你该怎么做呢？  
这个时候 kill 可能也未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里设定等待时间，如果在这个指定时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃，之后开发人员或者 DBA 再通过重试命令重复这个过程。

## 三、行锁
> 此处行锁相关讨论基于innoDB引擎

**MySQL的行锁是存储引擎单独实现的。**  
MyISAM引擎不支持行锁，所以其并发控制只能使用表锁。对于使用MyISAM引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。  
**InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一。**

### 1. 共享(S)锁和排它(X)锁
#### 1.1 基本概念
InnoDB实现标准的行级锁定，其中有两种类型的锁：<font color="red">**共享(S)锁**</font>和<font color="red">**排它(X)锁**</font>。

**共享(S)锁**：读锁，允许其他事务读取被锁定的对象，也可以在其上获取其他共享锁，但不能写入。和排他锁相反。  
**排它(X)锁**：写锁，根据事务隔离级别，这种锁可以能会阻止其他事务写入同一行，也可以会阻止其他事务读取同一行。默认的InnoDB隔离级别 **REPEATABLE READ** 通过允许事务读取具有排他锁的行来实现更高的并发性，这种技术称为 **一致读取**。

官网例子说明：
>如果事务T1在行r上持有共享(S)锁，那么来自某个不同事务T2的请求在行r上的锁将按如下方式处理：  
>* T2对S锁的请求可以立即被批准。因此，T1和T2都在行r上保持S锁。
>* T2对X锁的请求不能立即被批准。
>
>**如果事务T1在行r上持有排它(X)锁，则无法立即授予来自某个不同事务T2的请求r上任何一种类型的锁。因此，事务T2必须等待事务T1释放对行r的锁。**

<font color="red">**注意：排它(X)锁在锁住一行数据后，并不是其他事务就不能读取和修改该行数据，而是一个事务在一行数据加上排它(X)锁后，其他事务不能再在其上加其他的锁。**</font>

#### 1.2 行级锁命令SELECT ... LOCK IN SHARE MODE 和 SELECT ... FOR UPDATE
[官方文档：14.7.2.4 锁定读取](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html)  

**官方文档总结：**  
**SELECT … LOCK IN SHARE MODE：** 共享锁(S锁, share locks)。其他事务可以读取数据，但不能对该数据进行修改，直到所有的共享锁被释放。  
如果事务对某行数据加上共享锁之后，可进行读写操作；其他事务可以对该数据加共享锁，但不能加排他锁，且只能读数据，不能修改数据。  
**SELECT … FOR UPDATE：** 排他锁(X锁, exclusive locks)。如果事务对数据加上排他锁之后，则其他事务不能对该数据加任何的锁。获取排他锁的事务既能读取数据，也能修改数据。

<font color="red">**注意：**</font>  
<font color="red">**1.普通select ...from... 语句默认不加锁，而CUD操作默认加排他锁。**</font>  
<font color="red">**2.InnoDB行锁是通过给索引上的索引项加锁来实现的。所以，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。**</font>    
* **在不通过索引条件查询的时候，InnoDB使用的是表锁，而不是行锁。**
* **由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以即使是访问不同行的记录，如果使用了相同的索引键，也是会出现锁冲突的。**
* **当表有多个索引时，不同事务可以使用不同的索引锁定不同的行。另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会用行锁来对数据加锁。即便在条件中使用了索引字段，但具体是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。**

#### 1.3 两阶段锁协议
> **两阶段加锁(2PL)协议,而非两阶段提交(2PC)协议,区别如下:**  
> 2PL，两阶段加锁协议:主要用于单机事务中的一致性与隔离性。  
> 2PC，两阶段提交协议:主要用于分布式事务。

**概念：**  
当一个事务获取到了某一个数据库对象的锁之后，并不是当前事务不需要操作它了之后，这个锁就会马上释放掉，而是会一直被当前事务持有，直到这个事务被提交或回滚后，这个锁才会被释放。  
如：
| SessionA                      | SessionB                      |
| ----------------------------- | ----------------------------- |
| begin;                        |                               |
| update T set....Where id = 1; |                               |
| update T set....Where id = 2; |                               |
|                               | update T set....Where id = 1; |
| commit;                       | 阻塞                          |
|                               | 执行update语句                |
上表两个会话执行过程：  
1.SessionA开启事务，首先执行表T的修改（**id字段必须存在索引，行锁只能在索引上生效**），对id为1的行加锁；  
2.继续执行，修改id为2的行，此时对id为2的行加锁；虽然第一条语句已执行，但是整个事务并没有提交或者回滚，所以SessionA依旧持有id为1的锁。  
3.SessionB想要操作id为1的行，因为SessionA依旧持有id为1的行的锁，故SessionB会呗阻塞。  
4.SessionA提交事务，释放所持有的锁；SessionB执行修改语句。

**两阶段加锁对性能的影响：**  
当一个事务中需要执行多条语句（锁住多行）时，如上述SessionA的update1和update2语句，此时update1被持锁的时长会大于后续的语句，而其他事务又需要请求update1语句的锁，故等待锁释放的事件会很长。  

所以，如果一个事务中需要锁多个行，要把最可能造成 **锁冲突**、最可能**影响并发度**的锁（行）尽量放到离 **锁释放（commit/rollback）** 的更近的地方。这样这行影响并发度的行锁住的时间就会缩短。

#### 1.4 死锁
**死锁触发的条件：**
* 多个资源互斥访问
* 资源被获取后不可抢占
* 多个线程循环等待  

如：
| SessionA                                          | SessionB                                          |
| ------------------------------------------------- | ------------------------------------------------- |
| begin;                                            |                                                   |
| update T set....Where id = 1;（id=1行被锁住）     | begin;                                            |
|                                                   | update T set....Where id = 2;（id=2行被锁住）     |
| update T set....Where id = 2;（等待id=2行锁释放） |                                                   |
|                                                   | update T set....Where id = 1;（等待id=1行锁释放） |
| commit;                                           |                                                   |
|                                                   | commit;                                           |

<font color="red">**以上SessionA和SessionB都无法提交，持有的锁无法释放，一直处于阻塞状态**</font>  

**解决死锁的两种策略：**  
* <font color="red">**直接进入等待，直到超时。**</font> 这个超时时间可以通过参数 **innodb_lock_wait_timeout**来设置（**在InnoDB中，innodb_lock_wait_timeout的默认值是50s**）。  
这种策略在出现死锁是，会一直等待50s才会释放锁，对于系统来说时间太久，如果设置的时间过短，又无法区分是否是业务的正常等待，所以不建议使用这种策略。

* <font color="red">**发起死锁检测。**</font>发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。**将参数innodb_deadlock_detect设置为on，表示开启这个逻辑（默认是打开的）**。  
主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是是否出现死锁。
但是也是有缺点的： **这样的死锁检测会非常的占用内存，消耗CPU资源。**  所以要根据业务做一些取舍，或者使用中间件等；

### 2. 意向锁
**意向锁机制的实现过程中为了让行级锁定和表级锁定共存，** InnoDB也同样使用了意向锁（表级锁定）的概念，也就有了意向共享锁和意向排他锁这两种。

当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个**共享锁** 正锁定着自己需要的资源的时候，自己可以再加一个**共享锁**，**不过不能加排他锁**。  
但是，如果遇到自己需要锁定的资源已经被一个**排他锁**占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。

而意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。  
如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。

所以，可以说InnoDB的锁定模式实际上可以分为四种：**共享锁（S），排他锁（X），意向共享锁（IS）和意向排他锁（IX）**，我们可以通过以下表格来总结上面这四种所的共存逻辑关系：

|                  | 排他锁（X） | 意向排他锁（IX） | 共享锁（S） | 意向共享锁（IS） |
| ---------------- | ----------- | ---------------- | ----------- | ---------------- |
| 排他锁（X）      | 冲突        | 冲突             | 冲突        | 冲突             |
| 意向排他锁（IX） | 冲突        | 兼容             | 冲突        | 兼容             |
| 共享锁（S）      | 冲突        | 冲突             | 兼容        | 兼容             |
| 意向共享锁（IS） | 冲突        | 兼容             | 兼容        | 兼容             |



如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。
　　
### 3. 间隙锁（Next-Key锁）
**当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁**

对于键值在条件范围内但并不存在的记录，叫做**“间隙（GAP)”**，InnoDB也会对这个**“间隙”**加锁，**这种锁机制就是所谓的间隙锁（Next-Key锁）。**

如：  
emp表中只有101条记录，其empid的值分别是 1,2,...,100,101，下面的SQL：
```sql
select * from emp where empid > 100 for update;
```
是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的**“间隙”**加锁。

#### InnoDB使用间隙锁的目的：
**1. 防止幻读，以满足相关隔离级别的要求。**  
对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；  
**2. 为了满足其恢复和复制的需要。**  
很显然，在使用范围条件检索并锁定记录时，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。  
在某些场景下这可能会对性能造成很大的危害。  

除了间隙锁给InnoDB带来性能的负面影响之外，通过索引实现锁定的方式还存在其他几个较大的性能隐患：
* 当Query无法利用索引的时候，InnoDB会放弃使用行级别锁定而改用表级别的锁定，造成并发性能的降低；
* 当Query使用的索引并不包含所有过滤条件的时候，数据检索使用到的索引键所只想的数据可能有部分并不属于该Query的结果集的行列，但是也会被锁定，因为间隙锁锁定的是一个范围，而不是具体的索引键；
* 当Query在使用索引定位数据的时候，如果使用的索引键一样但访问的数据行不同的时候（索引只是过滤条件的一部分），一样会被锁定。

因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。

<font color="red">**注意：InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁**</font>  

## 四、 总结
### 1.什么时候使用表锁
对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁：
* 事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。
* 事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。
<font color="red">**当然，实际应用中这两种事务不能太多，否则，就应该考虑使用MyISAM表了。**</font> 
* 在InnoDB下，使用表锁要注意以下两点：
    * 使用LOCK TABLES虽然可以给InnoDB加表级锁，但必须说明的是，**表锁不是由InnoDB存储引擎层管理的，而是由其上一层──MySQL Server负责的，仅当autocommit=0、InnoDB_table_locks=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，** MySQL Server也才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁，否则，InnoDB将无法自动检测并处理这种死锁。
    * **在用 LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0，否则MySQL不会给表加锁** ；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁。

### 2.InnoDB行锁优化建议
**InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。**

当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势了。但是，InnoDB的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。

#### 要想合理利用InnoDB的行级锁定，需要注意一下几点：
* 尽可能让所有的数据检索都通过索引来完成，从而避免InnoDB因为无法通过索引键加锁而升级为表级锁定；
* 合理设计索引，让InnoDB在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他Query的执行；
* 尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录；
* 尽量控制事务的大小，减少锁定的资源量和锁定时间长度；
* **在业务环境允许的情况下，尽量使用较低级别的事务隔离**，以减少MySQL因为实现事务隔离级别所带来的附加成本。

#### 由于InnoDB的行级锁定和事务性，所以肯定会产生死锁，下面是一些比较常用的减少死锁产生概率的小建议：
* 类似业务模块中，尽可能按照相同的访问顺序来访问，防止产生死锁；
* 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
* 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。

#### 可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：
```sql
mysql> show status like 'InnoDB_row_lock%';
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| InnoDB_row_lock_current_waits | 0     |
| InnoDB_row_lock_time          | 0     |
| InnoDB_row_lock_time_avg      | 0     |
| InnoDB_row_lock_time_max      | 0     |
| InnoDB_row_lock_waits         | 0     |
+-------------------------------+-------+
```
InnoDB 的行级锁定状态变量不仅记录了锁定等待次数，还记录了锁定总时长，每次平均时长，以及最大时长，此外还有一个非累积状态量显示了当前正在等待锁定的等待数量。  
对各个状态量的说明如下：
**InnoDB_row_lock_current_waits：** 当前正在等待锁定的数量；  
**InnoDB_row_lock_time：** 从系统启动到现在锁定总时间长度；  
**InnoDB_row_lock_time_avg：** 每次等待所花平均时间；  
**InnoDB_row_lock_time_max：** 从系统启动到现在等待最常的一次所花的时间；  
**InnoDB_row_lock_waits：** 系统启动后到现在总共等待的次数。  

对于这5个状态变量，比较重要的主要是**InnoDB_row_lock_time_avg（等待平均时长），InnoDB_row_lock_waits（等待总次数）以及InnoDB_row_lock_time（等待总时长）这三项**。  
尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。