# MySQL 的全局锁、表锁和行锁

[部分官方文档：8.11.2 表锁定问题](https://dev.mysql.com/doc/refman/5.7/en/table-locking.html)  
[部分官方文档：14.7.1 InnoDB 锁定](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html)  

[文档内容参考1：MySQL：全局锁，表锁和行锁](https://blog.csdn.net/sayoko06/article/details/89945410)  
[文档内容参考2：mysql锁——innodb的行级锁](https://www.cnblogs.com/huangfuyuan/p/9510022.html)   
[文档内容参考3：innodb行锁：两阶段锁协议与死锁预防](https://www.jianshu.com/p/614143c9b1d3/)  


数据库为多用户共享的，当出现并发访问的时候，需要使用锁来控制资源的访问。  
根据加锁的范围，MySQL里面的锁大致可以分成 **全局锁** 、 **表级锁** 和 **行锁** 三类。

[toc]
## 一、全局锁
**全局锁就是对整个数据库实例进行加锁**。  
`MySQL` 提供了一个加全局读锁的方法，命令是 **<font color="red">Flush tables with read lock（FTWRL）</font>** 。

当你需要将整个库处于 **只读** 状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：包含数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

**主要的使用场景：**  
做全库逻辑备份的时候，为了保证备份期间的库在同一个逻辑时间点，使库处于只读状态，即保证一致性，但是这样子备份会导致很大问题（ **暂停写入，主从同步延迟** ）。

真正备份时，需要在`可重复读隔离级别`下开启一个事务。当逻辑备份`mysqldump`命令使用参数`–single-transaction`时，备份数据之前会启动一个事务，确保拿到一致性视图。而由于 **`MVCC`** 的支持，这个过程中的数据是可以正常更新的。

但是`–single-transaction` 只适用于 **支持事务引擎** 的库表。有些引擎是不支持事务的，比如`MyISAM`，因此只能通过`FTWRL`加全局锁的方式备份。

### set global readonly=true 方法

**`set global readonly=true`**方式，也可以让全库进入只读状态，但是仍然推荐`FTWRL`方式。

1. 有些系统中，`readonly`的值会被用来做其他逻辑，比如判断是主库还是备库。因此，修改`global`变量的方式影响面更大，不建议使用。
2. 异常处理机制上有差异。
- 如果执行`FTWRL`命令之后由于客户端发生异常断开，`MySQL`会自动释放这个全局锁，整个库回到可以正常更新的状态；
- 如果将整个库设置为`readonly`之后，如果客户端发生异常，则数据库就会一直保持`readonly`状态，会导致整个库长时间处于 **不可写** 状态。

### 小结
**不加锁而进行备份的问题可以参考事务的一致性。**

数据库全局锁 **（只读状态）** 的危险性：
* 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就能停止。
* 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的`binlog`日志，会导致主从延迟。

<font color="red">**注 ：业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。**</font>

## 二、表级锁
**表级锁就是对整张表进行加锁。**    
`MySQL`里面表级别的锁有两种：一种是`表锁`，一种是`元数据锁`（meta data lock，简称MDL)。

### 1. 表锁
表锁的语法是 `lock tables … read/write`。与 `FTWRL` 类似，可以用 `unlock tables` 主动释放锁，也可以在客户端断开的时候自动释放。  
需要注意，`lock tables` 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

举个例子：
```sql
-- 线程A执行以下语句
lock tables T1 read, T2 write;
```
执行到这里时，进入当前`线程A`：
* `T1`表仅允许 `线程A` **读** ，其他线程 如需 **写、更新** 要等待线程退出，`线程A` 如需 **写、更新** 会引发`mysql`报错。
* `T2`表仅允许 `线程A` **读写** 更新，其他线程 如需 **写、更新** 都会被阻塞，需等待空间退出 。
* `线程A`在执行`unlock tables`之前，也只能执行 **读`T1表`** 、 **读写`T2表`** 的操作。连 **写`T1表`** 都不允许，自然也不能访问其他表。

**注意：在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式，而对于 `InnoDB` 这种支持行锁的引擎，一般不使用 `lock tables（锁表）` 命令来控制并发，毕竟锁住整个表的影响还是很大。**

### 2. 元数据锁（meta data lock，MDL)
当我们有时候在操作表结构修改语句（`alert`）时，有时候会出现 **<font color="red">Waiting for table metadata lock</font>** 报错信息，一般都是进行`alter`操作时被 **阻塞** 了，导致了我们在使用语句` show processlist` 查看线程时 时，看到线程的状态是在等 `meta data lock（MDL）`，这就是 **元数据锁** 。

**`MDL` 不需要显示使用，在访问一个表的时候就会被自动加上。`MDL` 的作用是，保证读写的正确性。**

场景：  
如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对应不上，肯定是不行的。

因此在 `MySQL 5.5` 之后加入了MDL，当对一个表做增删改查操作的时候，加 `MDL` 读锁，当对表做结构变更操作的时候，加了 `MDL` 写锁：
* **<font color="red">读锁之间不互斥</font>** ，因此你可以有多个线程同时对一张表进行读取操作
* **<font color="red">读写之间、写写之间是互斥的</font>** ，用来保证变更结构操作的安全性。因此如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

**虽然 `MDL` 锁是系统默认加的，但是却不能忽略一个机制，比如下面一个例子：可能会给一个小表加字段，导致整个库都挂了。**  
如：  
当给一个表加字段、或者修改字段、或者加索引，需要扫描全表的数据。对大表操作的时候，需要特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出现问题。   

| session A        | session B        | session C                  | session D        |
| :--------------- | :--------------- | :------------------------- | :--------------- |
| begin :          |                  |                            |                  |
| select * from T; |                  |                            |                  |
|                  | select * from T; |                            |                  |
|                  |                  | alert T add new_field int; |                  |
|                  |                  |                            | seletc * from T; |

**`4`个`session`执行过程：**   
* `sessionA` 先启动，这个时候会对 T表 加一个 **`MDL`读锁**
* `sessionB` 需要的也是 **`MDL`读锁**，读锁之间不互斥，因此可以正常执行。
* `sessionC` 执行 **`alert`** 语句，修改数据库结构，会被阻塞，因为事务中的 **`MDL`锁** 还没有释放，在语句执行开始时申请，但是语句结束后并不会马上释放，而是等到事务提交之后再释放。所以 `sessionA` 读锁还没有释放而 `sessionC` 需要一个写锁，因此只能被阻塞。
*  如果再执行`sessionD`的`select`查询语句，虽然是需要 **`MDL`读锁** ；但是由于第三步`sessionC` 的 **`MDL`写锁** 被`block`住还没有释放，所以`sessionD` 也申请不到 **`MDL`读锁**，会被`blocked`，所以表就会完全变成不可读状态。  
而恰好 `T表` 读写比较频繁，而且如果客户端有重试机制，超时之后再重启一个新的 `session`，这个库的线程很快就会爆满。

**<font color="red">注意：一般行锁都有锁超时时间。但是`MDL`锁没有超时时间的限制，只要事务没有提交就会一直锁住。</font>**

#### 安全的给表加字段：
首先要解决长事务，如果事务一直不提交，就会一直占着 `MDL` 锁， 在 `MySQL` 的 **`information_schema库`** 的 **`innodb_trx表`** 中，你可以查看当前执行中的事务。如果你要做 `DDL` 变更的表刚好有长事务在执行， **<font color="red">要考虑先暂停 `DDL`，或者 `kill` 掉这个长事务</font>** 。

**但考虑一下这个场景：**   
如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，你不得不加字段，你该怎么做呢？  
这个时候 `kill` 可能也未必管用，因为新的请求马上就来了。比较理想的机制是，在 `alter table` 语句里设定等待时间，如果在这个指定时间里面能够拿到 `MDL` 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃，之后开发人员或者 `DBA` 再通过重试命令重复这个过程。

## 三、行锁
> 此处行锁相关讨论基于`innoDB`引擎

**`MySQL`的行锁是存储引擎单独实现的。**  
- `MyISAM`引擎不支持行锁，所以其并发控制只能使用表锁。对于使用`MyISAM引`擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。  
- **`InnoDB`是支持行锁的，这也是`MyISAM`被`InnoDB`替代的重要原因之一。**

### 1. 共享(S)锁和排它(X)锁
#### 1.1 基本概念
`InnoDB`实现标准的行级锁定，其中有两种类型的锁： **<font color="red">共享(S)锁</font>** 和 **<font color="red">排它(X)锁</font>** 。

- **共享(S)锁**：读锁，允许其他事务读取被锁定的对象，也可以在其上获取其他共享锁，但不能写入。和排他锁相反。  
- **排它(X)锁**：写锁，根据事务隔离级别，这种锁可以能会阻止其他事务写入同一行，也可以会阻止其他事务读取同一行。`InnoDB`默认的隔离级别 **`REPEATABLE READ`** 通过允许事务读取具有排他锁的行来实现更高的并发性，这种技术称为 **一致读取**。

**官网例子说明：**
>如果事务`T1`在`行r`上持有`共享(S)锁`，那么来自某个不同事务`T2`的请求在`行r`上的锁将按如下方式处理：  
>* `T2`对`S锁`的请求可以立即被批准。因此，`T1`和`T2`都在`行r`上保持`S锁`。
>* `T2`对`X锁`的请求不能立即被批准。
>
>**如果事务`T1`在`行r`上持有`排它(X)锁`，则无法立即授予来自某个不同事务`T2`的请求`行r`上任何一种类型的锁。因此，事务`T2`必须等待事务`T1`释放对`行r`的锁。**

**<font color="red">注意：`排它(X)锁`在锁住一行数据后，并不是其他事务就不能读取和修改该行数据，而是一个事务在一行数据加上`排它(X)锁`后，其他事务不能再在其上继续加其他的锁。</font>**

#### 1.2 行级锁命令`SELECT ... LOCK IN SHARE MODE` 和 `SELECT ... FOR UPDATE`
[官方文档：14.7.2.4 锁定读取](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html)  

**官方文档小结：**  
- **`SELECT … LOCK IN SHARE MODE`：** 共享锁(`S锁`, `share locks`)。  
其他事务可以读取数据，但不能对该数据进行修改，直到所有的共享锁被释放。如果事务对某行数据加上共享锁之后，可进行读写操作；其他事务可以对该数据加共享锁，但不能加排他锁，且只能读数据，不能修改数据。  
- **`SELECT … FOR UPDATE`：** 排他锁(`X锁`, `exclusive locks`)。  
如果事务对数据加上排他锁之后，则其他事务不能对该数据加任何的锁。获取排他锁的事务既能读取数据，也能修改数据。

**<font color="red">注意：</font>**
1. **<font color="red">普通`select ...from...`语句默认不加锁，而`CUD（增删改）`操作默认加排他锁。</font>**
2. **<font color="red">`InnoDB`行锁是通过给索引上的索引项加锁来实现的。所以，只有通过索引条件检索数据，`InnoDB`才使用行级锁，否则，`InnoDB`将使用表锁。</font>**

* **在不通过索引条件查询的时候，`InnoDB`使用的是表锁，而不是行锁。**
* **由于`MySQL`的行锁是针对索引加的锁，不是针对记录加的锁，所以即使是访问不同行的记录，如果使用了相同的`索引`键，也是会出现`锁冲突`的。**
* **当表有多个索引时，不同事务可以使用不同的`索引`锁定不同的行。  
另外，不论是使用`主键索引`、`唯一索引`或`普通索引`，`InnoDB`都会用`行锁`来对数据加锁。即便在条件中使用了索引字段，但具体是否使用索引来检索数据是由`MySQL`通过判断不同执行计划的代价来决定的；  
如果`MySQL`认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。  
因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。**

#### 1.3 两阶段锁协议
> **两阶段加锁(`2PL`)协议,而非两阶段提交(`2PC`)协议,区别如下:**  
> `2PL`，两阶段加锁协议：主要用于单机事务中的一致性与隔离性。  
> `2PC`，两阶段提交协议：主要用于分布式事务。

**概念：**  
当一个事务获取到了某一个数据库对象的锁之后，并不是当前事务不需要操作它了之后，这个锁就会马上释放掉，而是会一直被当前事务持有，直到这个事务被 **提交** 或 **回滚** 后，这个锁才会被释放。  
如：

| SessionA                      | SessionB                      |
| ----------------------------- | ----------------------------- |
| begin;                        |                               |
| update T set....Where id = 1; |                               |
| update T set....Where id = 2; |                               |
|                               | update T set....Where id = 1; |
| commit;                       | 阻塞                           |
|                               | 执行update语句                 |

上表两个会话执行过程：  
1. `SessionA`开启事务，首先执行`表T`的修改（**id字段必须存在索引，行锁只能在索引上生效**），对`id为1`的行加锁；
2. 继续执行，修改`id为2`的行，此时对`id为2`的行加锁；虽然第一条语句已执行，但是整个事务并没有 **提交** 或者 **回滚** ，所以`SessionA`依旧持有`id为1`的`行锁`。
3. `SessionB`想要操作`id为1`的行，因为`SessionA`依旧持有`id为1`的行的锁，故`SessionB`会被 **阻塞** 。
4. `SessionA`提交事务，释放所持有的锁；`SessionB`执行修改语句。

**两阶段加锁对性能的影响：**  
当一个事务中需要执行多条语句（锁住多行）时，如上述`SessionA`的`update1`和`update2`语句，此时`update1`被持锁的时长会大于后续的语句，而其他事务又需要请求`update1`语句的锁，故等待锁释放的事件会很长。  
所以，如果一个事务中需要锁多个行，要把最可能造成 **锁冲突** 、最可能 **影响并发度** 的锁（行）尽量放到离 **锁释放（`commit`/`rollback`）** 的更近的地方。这样这行影响并发度的行锁住的时间就会缩短。

#### 1.4 死锁
**死锁触发的条件：**
* 多个资源互斥访问
* 资源被获取后不可抢占
* 多个线程循环等待  

如：

| SessionA                                          | SessionB                                          |
| ------------------------------------------------- | ------------------------------------------------- |
| begin;                                            |                                                   |
| update T set....Where id = 1;（id=1行被锁住）      | begin;                                            |
|                                                   | update T set....Where id = 2;（id=2行被锁住）     |
| update T set....Where id = 2;（等待id=2行锁释放）  |                                                   |
|                                                   | update T set....Where id = 1;（等待id=1行锁释放） |
| commit;                                           |                                                   |
|                                                   | commit;                                           |

<font color="red">**以上`SessionA`和`SessionB`都无法提交，持有的锁无法释放，一直处于阻塞状态**</font>  

**解决死锁的两种策略：**  
* **<font color="red">直接进入等待，直到超时。</font>** 这个超时时间可以通过参数 **`innodb_lock_wait_timeout`**来设置（**在`InnoDB`中，`innodb_lock_wait_timeout`的默认值是`50s`** ）。  
这种策略在出现死锁是，会一直等待`50s`才会释放锁，对于系统来说时间太久，如果设置的时间过短，又无法区分是否是业务的正常等待，所以不建议使用这种策略。
* **<font color="red">发起死锁检测。</font>** 发现死锁后，主动 **回滚** 死锁链条中的某一个事务，让其他事务得以继续执行。**将参数`innodb_deadlock_detect`设置为`on`，表示开启这个逻辑（默认是打开的）**。  
主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是是否出现死锁。  
但是也是有缺点的： **这样的死锁检测会非常的占用内存，消耗`CPU`资源。**  所以要根据业务做一些取舍，或者使用中间件等。

### 2. 意向锁
**意向锁机制的实现过程中为了让行级锁定和表级锁定共存，** `InnoDB`也同样使用了`意向锁（表级锁定）`的概念，也就有了`意向共享锁`和`意向排他锁`这两种。

当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个 **`共享锁`** 正锁定着自己需要的资源的时候，自己可以再加一个 **`共享锁`** ，**不过不能加`排他锁`** 。  
但是，如果遇到自己需要锁定的资源已经被一个 **`排他锁`** 占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。

而`意向锁`的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被`排他锁`占用的时候，该事务可以需要锁定行的表上面添加一个合适的`意向锁`。  
如果自己需要一个`共享锁`，那么就在表上面添加一个`意向共享锁`。而如果自己需要的是某行（或者某些行）上面添加一个`排他锁`的话，则先在表上面添加一个`意向排他锁`。`意向共享锁`可以同时并存多个，但是`意向排他锁`同时只能有一个存在。

所以，可以说`InnoDB`的锁定模式实际上可以分为四种： **`共享锁（S）`，`排他锁（X）`，`意向共享锁（IS）`和`意向排他锁（IX）`** ，我们可以通过以下表格来总结上面这四种所的共存逻辑关系：

|                      | 排他锁（X） | 意向排他锁（IX）                    | 共享锁（S）                         | 意向共享锁（IS）                    |
| -------------------- | ----------- | ----------------------------------- | ----------------------------------- | ----------------------------------- |
| **排他锁（X）**      | 冲突        | 冲突                                | 冲突                                | 冲突                                |
| **意向排他锁（IX）** | 冲突        | **<font color="green">兼容</font>** | 冲突                                | **<font color="green">兼容</font>** |
| **共享锁（S）**      | 冲突        | 冲突                                | **<font color="green">兼容</font>** | **<font color="green">兼容</font>** |
| **意向共享锁（IS）** | 冲突        | **<font color="green">兼容</font>** | **<font color="green">兼容</font>** | **<font color="green">兼容</font>** |

**如果一个事务请求的锁模式与当前的锁兼容，`InnoDB`就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。**
　　
### 3. 间隙锁（`Next-Key`锁）
**当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，`InnoDB`会给符合条件的已有数据记录的索引项加锁**

对于键值在条件范围内但并不存在的记录，叫做 **“间隙（`GAP`)”** ，`InnoDB`也会对这个 **“间隙”** 加锁，**这种锁机制就是所谓的`间隙锁（Next-Key锁）`。**

如：  
`emp表`中只有`101`条记录，其`empid`的值分别是 `1,2,...,100,101`，有下面的`SQL`：
```sql
select * from emp where empid > 100 for update;
```
是一个范围条件的检索，`InnoDB`不仅会对符合条件的`empid值为101`的记录加锁，也会对`empid大于101`（但是这些记录并不存在）的 **“间隙”** 加锁。

#### `InnoDB`使用间隙锁的目的：
1. **防止幻读，以满足相关隔离级别的要求。**  
对于上面的例子，要是不使用间隙锁，如果其他事务插入了`empid大于100`的任何记录，那么本事务如果再次执行上述语句，就会发生 **幻读** ；  
2. **为了满足其恢复和复制的需要。**  
很显然，在使用范围条件检索并锁定记录时，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。  
在某些场景下这可能会对性能造成很大的危害。  

除了`间隙锁`给`InnoDB`带来性能的负面影响之外，通过索引实现锁定的方式还存在其他几个较大的性能隐患：
* 当`Query`无法利用`索引`的时候，`InnoDB`会放弃使用`行级别锁定`而改用`表级别锁定`，造成并发性能的降低；
* 当`Query`使用的`索引`并不包含所有过滤条件的时候，数据检索使用到的`索引键`所只想的数据可能有部分并不属于该`Query`的结果集的行列，但是也会被锁定，因为间隙锁锁定的是一个范围，而不是具体的`索引键`；
* 当`Query`在使用`索引`定位数据的时候，如果使用的`索引键`一样但访问的数据行不同的时候（`索引`只是过滤条件的一部分），一样会被锁定。

因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。

**<font color="red">注意：`InnoDB`除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，`InnoDB`也会使用`间隙锁`</font>**  

## 四、 总结
### 1.什么时候使用表锁
对于`InnoDB`表，在绝大部分情况下都应该使用`行级锁`，因为`事务`和`行锁往`往是我们之所以选择`InnoDB`引擎的理由。但在个别特殊事务中，也可以考虑使用·：
* 事务需要更新大部分或全部数据，表又比较大，如果使用默认的·，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用·来提高该事务的执行速度。
* 事务涉及多个表，比较复杂，很可能引起·，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。  
当然， **<font color="red">实际应用中这两种事务不能太多，否则，就应该考虑使用`MyISAM`引擎了。</font>**
* 在`InnoDB`下，使用表锁要注意以下两点：
    * 使用`LOCK TABLES`虽然可以给`InnoDB`加表级锁，但必须说明的是，**表锁不是由`InnoDB`存储引擎层管理的，而是由其上一层──`MySQL Server`负责的，仅当`autocommit=0`、`InnoDB_table_locks=1`（默认设置）时，`InnoDB`层才能知道`MySQL`加的`表锁`，** `MySQL Server`也才能感知`InnoDB`加的行锁，这种情况下，`InnoDB`才能自动识别涉及表级锁的`死锁`，否则`InnoDB`将无法自动检测并处理这种`死锁`。
    * **在用 `LOCK TABLES`对`InnoDB`表加锁时要注意，要将`AUTOCOMMIT`设为`0`，否则`MySQL`不会给表加锁** ；  
    事务结束前，不要用`UNLOCK TABLES`释放表锁，因为`UNLOCK TABLES`会隐含地 **提交事务** ；并且`COMMIT`或`ROLLBACK`并不能释放用`LOCK TABLES`加的表级锁，必须用`UNLOCK TABLES`释放表锁。

### 2.InnoDB行锁优化建议
**`InnoDB`存储引擎由于实现了`行级锁定`，虽然在锁定机制的实现方面所带来的性能损耗可能比`表级锁定`会要更高一些，但是在整体并发处理能力方面要远远优于`MyISAM`的`表级锁定`的。**

当系统并发量较高的时候，`InnoDB`的整体性能和`MyISAM`相比就会有比较明显的优势了。但是，`InnoDB`的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让`InnoDB`的整体性能表现不仅不能比`MyISAM`高，甚至可能会更差。

**要想合理利用`InnoDB`的`行级锁定`，需要注意一下几点：**
* **尽可能让所有的数据检索都通过`索引`来完成** ：从而避免`InnoDB`因为无法通过索引键加锁而升级为`表级锁定`；
* **合理设计`索引`，尽可能的缩小锁定范围** ：让`InnoDB`在`索引键`上面加锁的时候尽可能准确， 避免造成不必要的锁定而影响其他`Query`的执行；
* **尽可能减少基于范围的数据检索过滤条件** ：避免因为`间隙锁`带来的负面影响而锁定了不该锁定的记录；
* **尽量控制事务的大小**：减少锁定的资源量和锁定时间长度；
* **在业务环境允许的情况下，尽量使用较低级别的事务隔离**：以减少`MySQL`因为实现事务隔离级别所带来的附加成本。

**由于`InnoDB`的`行级锁定`和`事务性`，所以肯定会产生死锁，下面是一些比较常用的减少死锁产生概率的小建议：**
* 类似业务模块中，尽可能按照相同的访问顺序来访问，防止产生死锁；
* 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
* 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。

**可以通过检查`InnoDB_row_lock`状态变量来分析系统上的行锁的争夺情况：**
```sql
mysql> show status like 'InnoDB_row_lock%';
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| InnoDB_row_lock_current_waits | 0     |
| InnoDB_row_lock_time          | 0     |
| InnoDB_row_lock_time_avg      | 0     |
| InnoDB_row_lock_time_max      | 0     |
| InnoDB_row_lock_waits         | 0     |
+-------------------------------+-------+
```
`InnoDB` 的`行级锁定`状态变量不仅记录了锁定等待次数，还记录了 **锁定总时长，每次平均时长，以及最大时长，此外还有一个非累积状态量显示了当前正在等待锁定的等待数量。**   
对各个状态量的说明如下：
- **`InnoDB_row_lock_current_waits`：** 当前正在等待锁定的数量；  
- **`InnoDB_row_lock_time`：** 从系统启动到现在锁定总时间长度；  
- **`InnoDB_row_lock_time_avg`：** 每次等待所花平均时间；  
- **`InnoDB_row_lock_time_max`：** 从系统启动到现在等待最常的一次所花的时间；  
- **`InnoDB_row_lock_waits`：** 系统启动后到现在总共等待的次数。  

对于这`5`个状态变量，比较重要的主要是 **`InnoDB_row_lock_time_avg`（等待平均时长），`InnoDB_row_lock_waits`（等待总次数）以及`InnoDB_row_lock_time`（等待总时长）这三项** 。  
尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果制定优化计划。