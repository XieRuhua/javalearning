# 数据库连接池概念、原理、运行机制

[文档内容参考1：初探数据库连接池](https://zhuanlan.zhihu.com/p/69306001)  
[文档内容参考2：数据库连接池了解和常用连接池对比](https://www.cnblogs.com/whb11/p/11315463.html)  
[文档内容参考3：详解数据库连接池概念、原理、运行机制等](https://www.cnblogs.com/cocoxu1992/p/11031908.html)  
[文档内容参考4：常用数据库连接池 (DBCP、c3p0、Druid) 配置说明](https://www.cnblogs.com/JavaSubin/p/5294721.html)  


> 数据库连接池负责分配、管理和释放数据库连接，**它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个**；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。  
**这项技术能明显提高对数据库操作的性能**。  
>
>——————————《百度百科 - 数据库连接池》

**先讲一下“`池(Pool)`”：池技术在一定程度上可以明显优化服务器应用程序的性能，提高程序执行效率和降低系统资源开销。**  

这里所说的`池`是一种广义上的`池`，比如 **`数据库连接池`** 、 **`线程池`** 、 **`内存池`** 、 **`对象池`** 等。  
- 其中，`对象池`可以看成保存对象的容器，在进程初始化时创建一定数量的对象。 **<font color="red">需要时直接从池中取出一个空闲对象，用完后并不直接释放掉对象，而是再放到对象池中以方便下一次对象请求可以直接复用。</font>**   
- 其他几种池的设计思想也是如此，池技术的优势是，可以消除对象创建所带来的延迟，从而提高系统的性能。

[toc]
## 一、为什么要使用连接池
**`数据库连接`是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。**  
一个`数据库连接对象`均对应一个`物理数据库连接`，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的性能低下。

数据库连接池的解决方案是 **在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池(简单说：在一个“`池`”里放了好多半成品的数据库联接对象)，由应用程序动态地对池中的连接进行申请、使用和释放。**  
对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。

**连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。同时，可以通过连接池自身的管理机制来监视数据库连接的数量、使用情况等。**

## 二、工作原理
连接池的工作原理主要由三部分组成：
* 池的建立
* 池中连接的使用管理
* 池的关闭

### 1. 连接池的建立
一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。

**连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。**  

### 2.连接池的管理
**`连接池管理策略`是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。**  

连接池管理策略：
* 当客户请求数据库连接时，首先查看连接池中是否有空闲连接：
    * 如果存在空闲连接，则将连接分配给客户使用；  
    * 如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；
    * 如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间还是无法获取到连接，则抛出异常给客户。
* 当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。

**该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。**

#### 移除无效连接：
**无效连接，即不能正确连接到数据库服务器的连接。**   

对于连接池来说，存储的与数据库服务器的连接的数量是有限的。因此，对于无效连接，如果如不及时移除，将会浪费连接池的空间。  
**<font color="red">如果连接长时间空闲，或检测到与服务器的连接已断开，`连接池管理器`会将该连接从池中移除。</font>**

### 3.连接池的关闭
当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，**该过程正好与创建相反。**

## 三、与传统的连接机制的区别
### 1. 不使用连接池
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/JavaLearning/数据库/数据库连接池概念、原理、运行机制/不使用连接池.png)
</center>

**不使用数据库连接池的步骤：**  
1. `TCP`建立连接的三次握手（`JDBC`与`MySQL`的连接基于`TCP`协议）
2. `MySQL`认证的三次握手
3. **真正的SQL执行**
4. `MySQL`的关闭
5. `TCP`的四次挥手关闭

可以看到，为了执行一条`SQL`，产生了非常多我们不关心的网络交互。

**优点：**  
实现简单

**缺点：**  
* `网络IO`较多
* 数据库的负载较高
* 响应时间较长及`QPS`较低（每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准）
* 应用频繁的创建连接和关闭连接，导致临时对象较多，`GC`频繁
* 在关闭连接后，会出现大量`TIME_WAIT`的`TCP`状态（在`2`个`MSL`之后关闭）

### 2. 使用连接池
<center>

![](https://cdn.jsdelivr.net/gh/XieRuhua/images/JavaLearning/数据库/数据库连接池概念、原理、运行机制/使用连接池.png)
</center>

**使用数据库连接池的步骤：**  
1. 第一次访问的时候，需要建立连接。   
2. 之后的访问，均会复用之前创建的连接，直接执行`SQL`语句。
3. 当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，`TCP`的四次挥手关闭

**优点：**  
* 较少了网络开销
* 系统的性能会有一个实质的提升
* 没了麻烦的`TIME_WAIT`状态

**缺点：**  
为了发挥数据库连接池的作用，在初始化时将创建一定数量的数据库连接放到连接池中

## 四、连接池关键配置参数
为了发挥数据库连接池的作用，在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。  
连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。

**最小连接数：**  
是数据库一直保持的数据库连接数，所以如果应用程序对数据库连接的使用量不大，将有大量的数据库资源被浪费。

**初始化连接数：**  
连接池启动时创建的初始化数据库连接数量。

**最大连接数：**  
是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求被加入到等待队列中。

**最大等待时间：**  
当没有可用连接时，连接池等待连接被归还的最大时间，超过时间则抛出异常， **可设置参数为`0`或者负数使得无限等待** （根据不同连接池配置）。

## 五、常用连接池对比
### 1. 常见数据库连接池及其特点
在Java中开源的常用的数据库连接池有以下几种 ：

#### 1.1 DBCP
`DBCP`是一个依赖`Jakarta commons-pool`对象池机制的数据库连接池。`DBCP`可以直接的在应用程序中使用，`Tomcat`的数据源使用的就是`DBCP`。

#### 1.2 c3p0
`c3p0`是一个开放源代码的`JDBC连接池`，它在`lib`目录中与`Hibernate`一起发布,包括了实现`jdbc3`和`jdbc2`扩展规范说明的`Connection` 和`Statement 池`的`DataSources` 对象。

#### 1.3 Druid
阿里出品，淘宝和支付宝专用数据库连接池，但它不仅仅是一个数据库连接池；它还包含一个`ProxyDriver`，一系列内置的`JDBC组件库`，一个`SQL Parser`。  
支持所有`JDBC`兼容的数据库，包括`Oracle`、`MySql`、`Derby`、`Postgresql`、`SQL Server`、`H2`等等。

**简单`SQL`语句用时`10微秒`以内，复杂`SQL`用时`30微秒`。**  
通过`Druid`提供的`SQL Parser`可以在JDBC层拦截SQL做相应处理，比如说分库分表、审计等。 **`Druid`防御`SQL`注入攻击的`WallFilter`就是通过`Druid的SQL Parser`分析语义实现的。** 

### 2. 主要配置说明
#### 2.1 基本配置
基本配置是指连接池进行数据库连接的四个基本必需配置：  
传递给`JDBC驱动`的用于连接数据库的 **用户名** 、 **密码** 、 **URL** 、 **驱动类名** 。

|              | DBCP            | c3p0        | Druid           |
| ------------ | --------------- | ----------- | --------------- |
| **用户名**   | username        | user        | username        |
| **密码**     | password        | password    | password        |
| **URL**      | url             | jdbcUrl     | jdbcUrl         |
| **驱动类名** | driverClassName | driverClass | driverClassName |

**注：在`Druid`连接池的配置中，`driverClassName`可配可不配，如果不配置会根据`url`自动识别`dbType`(数据库类型)，然后选择相应的`driverClassName`。**

#### 2.2 关键配置
|                  | DBCP                | c3p0               | Druid          |
| ---------------- | ------------------- | ------------------ | -------------- |
| **最小连接数**   | minIdle(0)          | minPoolSize(3)     | minIdle(0)     |
| **初始化连接数** | initialSize(0)      | initialPoolSize(3) | initialSize(0) |
| **最大连接数**   | maxTotal(8)         | maxPoolSize(15)    | maxActive(8)   |
| **最大等待时间** | maxWaitMillis(毫秒) | maxIdleTime(0秒)   | maxWait(毫秒)  |

**注1：在`DBCP连接池`的配置中，还有一个`maxIdle`的属性，表示最大空闲连接数，超过的空闲连接将被释放，默认值为`8`。  
对应的该属性在`Druid连接池`已不再使用，配置了也没有效果，`c3p0连接池`则没有对应的属性。**

**注2：数据库连接池在初始化的时候会创建`initialSize个`连接，当有数据库操作时，会从池中取出一个连接。  
如果当前池中正在使用的`连接数等于maxActive`，则会等待一段时间，等待其他操作释放掉某一个连接，如果这个等待时间超过了maxWait，则会报错；  
如果当前正在使用的`连接数小于maxActive`，则判断当前是否空闲连接，如果有则直接使用空闲连接，如果没有则新建立一个连接。<font color="red">在连接使用完毕后，不是将其物理连接关闭，而是将其放入池中等待其他操作复用。</font>**

#### 2.3 性能配置
##### 2.3.1 预缓存设置：
**即`PSCache`，`PSCache`对支持游标的数据库性能提升巨大，比如说`oracle`。**   
`JDBC`的标准参数，用以控制数据源内加载的`PreparedStatements`数量。但由于预缓存的`statements`属于`单个connection`而不是整个连接池，所以设置这个参数需要考虑到多方面的因素。

**单个连接拥有的最大缓存数：** 要启用`PSCache`，必须配置大于`0`，当大于`0`时，`poolPreparedStatements`自动触发修改为`true`。   
**在`Druid`中，不会存在`Oracle下PSCache`占用内存过多的问题，可以把这个数值配置大一些，比如说`100`**

|                              | DBCP                       | c3p0                        | Druid                      |
| ---------------------------- | -------------------------- | --------------------------- | -------------------------- |
| **开启缓存功能**              | poolPreparedStatements     | maxStatements               | poolPreparedStatements     |
| **单个连接拥有的最大缓存数**   | maxOpenPrepared-Statements | maxStatementsPer-Connection | maxOpenPrepared-Statements |

##### 2.3.2 连接有效性检测设置：
连接池内部有机制判断，如果当前的总的连接数少于 **`miniIdle`** ，则会建立新的空闲连接，以保证连接数得到 **`miniIdle`** 。  
如果当前连接池中某个连接在空闲了 **`timeBetweenEvictionRunsMillis`** 时间后任然没有使用，则被物理性的关闭掉。

有些数据库连接的时候有超时限制（`mysql`连接在`8小时`后断开），或者由于网络中断等原因，连接池的连接会出现失效的情况，这时候设置一个 **`testWhileIdle参数为true`** ，可以保证连接池内部定时检测连接的可用性，不可用的连接会被抛弃或者重建，最大情况的保证从连接池中得到的`Connection对象`是可用的。

**当然，为了保证绝对的可用性，你也可以使用`testOnBorrow`为`true`（即在获取`Connection`对象时检测其可用性），不过这样会影响性能。**

|                   | DBCP                          | c3p0                     | Druid                         |
| ----------------- | ----------------------------- | ------------------------ | ----------------------------- |
| **申请连接检测**   | testOnBorrow                  | testConnectionOnCheckin  | testOnBorrow                  |
| **是否超时检测**   | testWhileIdle                 |     ——                   | testWhileIdle                 |
| **空闲时间**       | timeBetweenEvictionRunsMillis | idleConnectionTestPeriod | timeBetweenEvictionRunsMillis |
| **校验用sql语句** | validationQuery                | preferredTestQuery       | validationQuery               |
| **归还连接检测**   | testOnReturn                  | testConnectionOnCheckout | testOnReturn                  |

##### 2.3.3 超时连接关闭设置：
**`removeAbandoned`** 参数：用来检测到当前使用的连接是否发生了连接泄露，所以在代码内部就假定如果一个连接建立连接的时间很长，则将其认定为泄露，继而强制将其关闭掉。

|                      | DBCP                   | c3p0                     | Druid                  |
| -------------------- | ---------------------- | ------------------------ | ---------------------- |
| **是否超时关闭连接**   | removeAbandoned        | breakAfterAcquireFailure | removeAbandoned        |
| **超时时间**          | removeAbandonedTimeout | checkoutTimeout          | removeAbandonedTimeout |
| **是否记录日志**      | logAbandoned           | ——                       | logAbandoned           |

## 六、连接池需要注意的点（总结）
### 1. 并发问题
为了使连接管理服务具有最大的通用性，必须考虑多线程环境，即并发问题。  
这个问题相对比较好解决，因为各个语言自身提供了对并发管理的支持像`java`、`c#`等等，使用`synchronized(java)`、`lock(C#)`关键字或其他锁机制即可确保线程是同步的。

### 2. 事务处理
事务具有原子性，此时要求对数据库的操作符合 **“`ALL-OR-NOTHING`”** 原则，即对于一组`SQL`语句要么全做，要么全不做。

当`2`个线程共用一个连接`Connection`对象，而且各自都有自己的事务要处理时候，对于连接池是一个很头疼的问题，因为即使`Connection`类提供了相应的事务支持，可是仍然不能确定那个数据库操作是对应那个事务的，这是由于有`2`个线程都在进行事务操作而引起的。    
**为此可以使用每一个事务独占一个连接来实现，虽然这种方法有点浪费连接池资源但是可以大大降低事务管理的复杂性。**

### 3. 连接池的分配与释放
**连接池的分配与释放，对系统的性能有很大的影响。合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。**

对于连接的管理可使用一个`List`，即把已经创建的连接都放入`List`中去统一管理。  
每当用户请求一个连接时，系统检查这个`List`中有没有可以分配的连接。如果有就把那个最合适的连接进行分配；如果没有就抛出一个异常给用户（或者持续等待），`List`中连接是否可以被分配由一个线程来专门管理。

### 4. 连接池的配置与维护
**连接池中到底应该放置多少连接，才能使系统的性能最佳？**  
系统可采取设置最小连接数（ **`minConnection`** ）和最大连接数（ **`maxConnection`** ）等参数来控制连接池中的连接。

最小连接数是系统启动时连接池所创建的连接数。**如果创建过多，则系统启动就慢，但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，后续响应起来却慢。**  
因此，可以在开发时，设置较小的最小连接数，开发起来会快；而在系统实际使用时（生产环境）设置较大的，因为这样对访问客户来说速度会快些。

**<font color="red">最大连接数是连接池中允许连接的最大数目，具体设置多少，要看系统的访问量，可通过业务需求上得到。</font>**

**如何确保连接池中的最小连接数呢？**  
有动态和静态两种策略：
* `动态`即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接,以保证连接池的正常运转。
* `静态`是发现空闲连接不够时再去检查。