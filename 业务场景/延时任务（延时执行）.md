延时任务（延时执行）

[参考文档链接1：面试官问：生成订单30分钟未支付，则自动取消，该怎么实现？](https://mp.weixin.qq.com/s/8MKWsnGNPPlPwUKAfDV2TA)  
[参考文档链接2：10种延迟任务实现方式](https://blog.csdn.net/echizao1839/article/details/105533214)  

## 什么是延时任务
**延时任务即需要延时执行的任务。**

**需要用到延迟任务的使用场景：**
* 红包 24 小时未被查收，需要延迟执退还业务；
* 每个月账单日，需要给用户发送当月的对账单；
* 生成订单60秒后,给用户发短信；
* 订单下单之后 30 分钟后，用户如果没有付钱，系统需要自动取消订单。
* ..........................

对上述的任务，我们给一个专业的名字来形容，那就是 **延时任务**。  
**那么延时任务和定时任务有什么区别呢？**
* 定时任务有明确的触发时间，延时任务没有
* 定时任务有执行周期，而延时任务在某事件触发后一段时间内执行，没有执行周期这个概念
* 定时任务一般执行的是批处理操作是多个任务，而延时任务一般是单个任务

## 方案1. 无限循环实现延迟任务（轮询数据库）
此方式我们需要开启一个无限循环一直扫描任务，然后使用一个 Map 集合用来存储任务和延迟执行的时间，实现代码如下：
```java
import java.time.Instant;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class DelayTask {
    // 存放延时任务
    private static Map<String, Long> _TaskMap = new HashMap<>();
 
    public static void main(String[] args) {
        System.out.println("程序启动时间：" + LocalDateTime.now());
        // 添加延时任务
        _TaskMap.put("task-1", Instant.now().plusSeconds(3).toEpochMilli()); // 延迟 3s
        _TaskMap.put("task-2", Instant.now().plusSeconds(10).toEpochMilli()); // 延迟 10s
 
        // 调用无限循环实现延迟任务
        loopTask();
    }
 
    /**
     * 无限循环实现延迟任务
     */
    public static void loopTask() {
        Long itemLong = 0L;
        while (true) {
            Iterator it = _TaskMap.entrySet().iterator();
            while (it.hasNext()) {
                Map.Entry entry = (Map.Entry) it.next();
                itemLong = (Long) entry.getValue();
                // 有任务需要执行
                if (Instant.now().toEpochMilli() >= itemLong) {
                    // 延迟任务，业务逻辑执行
                    System.out.println("执行任务：" + entry.getKey() +
                            " ，执行时间：" + LocalDateTime.now());
                    // 删除任务
                    _TaskMap.remove(entry.getKey());
                }
            }
        }
    }
}
```

**执行结果为：**  
```
程序启动时间：2021-09-16T15:43:20.560
执行任务：task-1 ，执行时间：2021-09-16T15:43:23.566  
执行任务：task-2 ，执行时间：2021-09-16T15:43:30.566
```
可以看出任务1和任务2分别延迟了 **3s** 和 **10s** 执行了，符合我们的预期。

## 方案2. Java API 实现延时任务
Java API 提供了两种实现延迟任务的方法：**DelayQueue** 和 **ScheduledExecutorService**。

### 1. ScheduledExecutorService 实现延时任务
我们可以使用 ScheduledExecutorService 来以固定的频率一直执行任务，实现代码如下：
```
import java.time.LocalDateTime;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class DelayTask {

    // 执行的数量，用于停止任务
    public static int doCount = 5;

    public static void main(String[] args) {
        System.out.println("程序启动时间：" + LocalDateTime.now());
        scheduledExecutorServiceTask();
    }

    /**
     * ScheduledExecutorService 实现固定频率一直循环执行任务
     */
    public static void scheduledExecutorServiceTask() {
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
        executor.scheduleWithFixedDelay(
                new Runnable() {
                    @Override
                    public void run() {
                        // 执行任务的业务代码
                        System.out.println("执行任务" + " ，执行时间：" + LocalDateTime.now());

                        doCount --;
                        // 判断是否终止延时任务
                        if(doCount <= 0){
                            executor.shutdown();
                        }
                    }
                },
                2, // 初次执行间隔
                3, // 3s 执行一次
                TimeUnit.SECONDS);
    }
}

```
**执行结果为：**  
```
程序启动时间：2021-09-16T16:17:18.732
执行任务 ，执行时间：2021-09-16T16:17:20.830
执行任务 ，执行时间：2021-09-16T16:17:23.845
执行任务 ，执行时间：2021-09-16T16:17:26.850
执行任务 ，执行时间：2021-09-16T16:17:29.856
执行任务 ，执行时间：2021-09-16T16:17:32.869
```
可以看出使用 **ScheduledExecutorService$scheduleWithFixedDelay(...)**  方法之后，会以某个频率一直循环执行延迟任务。直到调用 **shutdown()** 方法之后才会退出循环。

### 2. DelayQueue 实现延时任务
**DelayQueue** 是一个支持延时获取元素的无界阻塞队列，队列中的元素必须实现 Delayed 接口，并重写 **getDelay(TimeUnit)** 和 **compareTo(Delayed)** 方法，DelayQueue 实现延迟队列的完整代码如下
```
import java.text.DateFormat;
import java.util.Date;
import java.util.concurrent.*;

public class DelayTask {

    public static void main(String[] args) throws InterruptedException {
        DelayQueue delayQueue = new DelayQueue();
        // 添加延迟任务
        delayQueue.put(new DelayElement(1000));
        delayQueue.put(new DelayElement(3000));
        delayQueue.put(new DelayElement(5000));
        System.out.println("开始时间：" + DateFormat.getDateTimeInstance().format(new Date()));
        while (!delayQueue.isEmpty()) {
            // 执行延迟任务
            System.out.println(delayQueue.take());
        }
        System.out.println("结束时间：" + DateFormat.getDateTimeInstance().format(new Date()));
    }

    static class DelayElement implements Delayed {
        // 延迟截止时间（单面：毫秒）
        long delayTime = System.currentTimeMillis();

        public DelayElement(long delayTime) {
            this.delayTime = (this.delayTime + delayTime);
        }

        @Override
        // 获取剩余时间
        public long getDelay(TimeUnit unit) {
            return unit.convert(delayTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);
        }

        @Override
        // 队列里元素的排序依据
        public int compareTo(Delayed o) {
            if (this.getDelay(TimeUnit.MILLISECONDS) > o.getDelay(TimeUnit.MILLISECONDS)) {
                return 1;
            } else if (this.getDelay(TimeUnit.MILLISECONDS) < o.getDelay(TimeUnit.MILLISECONDS)) {
                return -1;
            } else {
                return 0;
            }
        }

        @Override
        public String toString() {
            return DateFormat.getDateTimeInstance().format(new Date(delayTime));
        }
    }
}
```
**执行结果为：**  
```
开始时间：2021-9-16 16:37:13
2021-9-16 16:37:14
2021-9-16 16:37:16
2021-9-16 16:37:18
结束时间：2021-9-16 16:37:18
```
## 方案3. Redis 实现延迟任务
使用 Redis 实现延迟任务的方法大体可分为两类：**通过zset数据判断** 的方式、**通过键空间通知**的方式。
### 1. 通过zset数据判断
测试案例用的Jedis连接redis，实际项目中一般会有工具类，不推荐直接使用Jedis
```
<!-- Jedis依赖 -->
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
    <version>2.7.1</version><!--版本号可根据实际情况填写-->
</dependency>
```
java代码：
```java
import redis.clients.jedis.Jedis;

import java.time.Instant;
import java.util.Set;

public class DelayTask {
    // zset key
    private static final String _KEY = "myDelayQueue";

    public static void main(String[] args) throws InterruptedException {
        // redis连接，实际项目中一般会有工具类，不推荐使用Jedis
        Jedis jedis = new Jedis("127.0.0.1", 6379);
        jedis.auth("123456");

        // 延迟 30s 执行（30s 后的时间）
        long delayTime = Instant.now().plusSeconds(30).getEpochSecond();
        jedis.zadd(_KEY, delayTime, "order_1");
        // 继续添加测试数据
        jedis.zadd(_KEY, Instant.now().plusSeconds(2).getEpochSecond(), "order_2");
        jedis.zadd(_KEY, Instant.now().plusSeconds(2).getEpochSecond(), "order_3");
        jedis.zadd(_KEY, Instant.now().plusSeconds(7).getEpochSecond(), "order_4");
        jedis.zadd(_KEY, Instant.now().plusSeconds(10).getEpochSecond(), "order_5");
        // 开启延迟队列
        doDelayQueue(jedis);
    }

    /**
     * 延迟队列消费
     * @param jedis Redis 客户端
     */
    public static void doDelayQueue(Jedis jedis) throws InterruptedException {
        while (true) {
            // 当前时间
            Instant nowInstant = Instant.now();
            long lastSecond = nowInstant.plusSeconds(-1).getEpochSecond(); // 上一秒时间
            long nowSecond = nowInstant.getEpochSecond();
            // 查询当前时间的所有任务
            Set<String> data = jedis.zrangeByScore(_KEY, lastSecond, nowSecond);
            for (String item : data) {
                // 消费任务
                System.out.println("消费：" + item);
            }
            // 删除已经执行的任务
            jedis.zremrangeByScore(_KEY, lastSecond, nowSecond);
            Thread.sleep(1000); // 每秒轮询一次
        }
    }
}
```
打断点观察redis中存放的数据为：
```
+-------+---------+-------------+
| row 	| value   | score		|
+-------+---------+-------------+
| 1 	| order_2 | 1631782893	|
| 2 	| order_3 | 1631782895	|
| 3 	| order_4 | 1631782898	|
| 4 	| order_5 | 1631782901	|
| 5 	| order_1 | 1631782921	|
+-------+---------+-------------+
```

**执行结果为：**  
```
消费：order_2
消费：order_3
消费：order_4
消费：order_5
消费：order_1
```

### 2. 通过键空间通知（todo）
默认情况下 Redis 服务器端是不开启键空间通知的，需要我们通过修改配置文件redis.conf
```
# E代表键事件通知；x代表过期事件，每当有过期键被删除时发送
config set notify-keyspace-events Ex
```
<!--开启键空间通知后，我们就可以拿到每个键值过期的事件，通过这个机制实现了给每个人开启一个定时任务的功能，实现代码如下：-->
```java

```
**执行结果为：**  
```

```


## 方案4. 
## 方案5. 
## 方案6. 
## 方案7. 
## 方案8. 
## 方案9. 
## 方案10.